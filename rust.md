---
title: Learning Rust
date: 2021-06-16 00:39:24
tags:
    - Rust
    - Programing language
    - Learn-note
categories: Language
toc: true
---

é˜…è¯»  [rust online book](https://doc.rust-lang.org/book/) æ—¶è®°å½•çš„ç¬”è®°ï¼Œè¾…ä»¥å¤‡å¿˜ã€‚

<!-- more -->

Rustå…·æœ‰å®‰å…¨é«˜æ•ˆç­‰è¯­è¨€ç‰¹æ€§ï¼Œæä¾›äº†3ä¸ªå·¥å…·ï¼š

- cargo: ä¾èµ–ç®¡ç†å’Œæ„å»ºå·¥å…·
- rustfmt: ä»£ç é£æ ¼
- Rust Language Server

# ä¸€ã€å¼€å§‹å­¦ä¹ rust

## hello, world

``` rust
// main.rs
fn main() {
    println!("hello, world!");
}
```

å¯¹äºè¿™ä¸ªèµ·ç‚¹ç¨‹åºï¼Œå’ŒCè¯­è¨€ç±»ä¼¼ï¼Œmain å‡½æ•°æ˜¯ rust ç¨‹åºçš„å…¥å£ï¼Œå‡½æ•°ä½“ä½¿ç”¨ '{}' åŒ…å›´ï¼Œå°†å·¦å¤§æ‹¬å·å’Œå‡½æ•°å£°æ˜æ”¾åœ¨ä¸€è¡Œæ˜¯ rust æ¨èçš„ç¼–ç¨‹ä¹ æƒ¯,æ­¤å¤–ï¼Œrust è¯­è¨€é£æ ¼ä½¿ç”¨ 4 ä¸ªç©ºæ ¼æ¥ç¼©è¿›ï¼Œè€Œé TABï¼Œä¸”ä½¿ç”¨åˆ†å·ä½œä¸ºæ¯ä¸ªè¯­å¥è¡¨è¾¾çš„ç»“æŸã€‚å¯ä»¥ä½¿ç”¨ rustfmt å·¥å…·æ ¼å¼åŒ–ä»£ç ä¸ºå®˜æ–¹æ¨èçš„æ ¼å¼

``` shell
> rustfmt main.rs
```

å’Œcè¯­è¨€æœ‰æ‰€åŒºåˆ«çš„æ˜¯ï¼Œç”¨äºè¾“å‡ºçš„è¯­å¥ "println!" éå‡½æ•°ï¼Œè€Œæ˜¯ Rust macroï¼Œå®ƒå’Œå‡½æ•°çš„ç›´è§‚ä¸Šçš„åŒºåˆ«åœ¨äºæ˜¯å¦æœ‰ "!"ï¼Œè‹¥ "func_name" åˆ™ä¸ºä¸€ä¸ªæ™®é€šçš„å‡½æ•°

å¯¹äºç®€å•çš„ rust ç¨‹åºï¼Œå¯ä»¥ä½¿ç”¨ rustc è¿›è¡Œç¼–è¯‘ï¼Œå¹¶å¾—åˆ°å¯è¿è¡Œçš„äºŒè¿›åˆ¶æ–‡ä»¶

``` shell
> rustc main.rs
```

ç„¶è€Œå¯¹äºå¤æ‚çš„å·¥ç¨‹ï¼Œä½¿ç”¨ cargo æ¥ç®¡ç†é¡¹ç›®åˆ™æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚

## ä½¿ç”¨ Cargo

Cargo æ˜¯ Rust è¯­è¨€ç³»ç»Ÿä¸­çš„ä¾èµ–ç®¡ç†å’Œæ„å»ºå·¥å…·ã€‚åˆ©ç”¨cargoåˆ›å»ºæ–°çš„é¡¹ç›®ï¼Œå¹¶åˆ›å»ºæ‰€éœ€çš„æ–‡ä»¶é¡¹ï¼ŒåŒæ—¶åœ¨é git ä»“åº“ä¸­å°†åŒæ—¶åˆå§‹åŒ– git å¹¶æ·»åŠ  gitignore æ–‡ä»¶ã€‚

``` shell
> cargo new hello_cargo
> tree hello_cargo
  |- Cargo.toml
  |- src
    |- main.rs

```

åœ¨ Cargo.toml æ–‡ä»¶ä¸­è®°å½•äº†é¡¹ç›®ç›¸å…³ä¿¡æ¯å’Œä¾èµ–é¡¹ç›®ï¼Œæ–‡ä»¶ä¸ºTOML (Tomâ€™s Obvious, Minimal Language) æ ¼å¼ã€‚Cargo è®¾è®¡å¸Œæœ›å°†æºç æ”¾åˆ° srcç›®å½•ä¸­ï¼Œé¡¶å±‚ç›®å½•æ”¾ç½® READMEã€LICENSE ç­‰ã€‚

æ„å»ºå’Œè¿è¡Œä½¿ç”¨ Cargo åˆ›å»ºçš„é¡¹ç›®å¾ˆç®€å•ï¼Œåœ¨ç¬¬ä¸€æ¬¡æ„å»ºå®Œæˆåï¼Œåœ¨é¡¶å±‚ç›®å½•å°†åˆ›å»ºä¸€ä¸ª Cargo.lock æ–‡ä»¶ç”¨ä»¥è®°å½•ä¾èµ–ï¼Œæ— éœ€æ‰‹å·¥ç®¡ç†ã€‚

``` shell
> cd hello_cargo
# write binary file into target/
> cargo build 
# exec the program
> cargo run
# or exec the binary file direcly
> ./target/debug/hello_cargo
```

æ­¤å¤– Cargo æä¾›äº†å¿«é€Ÿæ£€æµ‹ä»£ç ä½†ä¸ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶çš„å‘½ä»¤ï¼Œå…¶é€Ÿåº¦å¿«äº buildï¼Œæ‰€ä»¥ç»å¸¸ check ä¸€ä¸‹åˆšåˆšå†™çš„ä»£ç æ˜¯ä¸ªå¾ˆå¥½çš„ä¹ æƒ¯ã€‚ 

``` shell
> cargo check
```

å½“ç¨‹åºå‘ç‰ˆä½¿ç”¨æ—¶ï¼Œä½¿ç”¨å¸¦æœ‰ --release å‚æ•°çš„ build å‘½ä»¤ç”Ÿæˆ release ç‰ˆæœ¬ï¼Œç¼–è¯‘å™¨ä¼˜åŒ–å°†ä½¿ç¨‹åºå…·å¤‡æ›´é«˜æ•ˆçš„è¿è¡Œæ•ˆç‡ï¼Œä½†æ˜¯ç¼–è¯‘æ—¶é—´ä¼šæ›´é•¿ã€‚

``` shell
> cargo build --release
```

# äºŒã€çŒœæ•°ç¨‹åºå®è·µ

å®è·µæ°¸è¿œæ˜¯å­¦ä¹ æ–°ä¸œè¥¿æœ€å¿«çš„æ–¹æ³•ã€‚ä¸‹é¢ä½¿ç”¨ç†ŸçŸ¥çš„çŒœæ•°æ¸¸æˆå­¦ä¹ ä¸€äº›æ–°çš„è¯­è¨€è§„åˆ™ã€‚

é¦–å…ˆï¼Œä½¿ç”¨åœ¨ä¸Šä¸€ç«  hello world ç¨‹åºçš„åŸºç¡€ä¸Šï¼Œå¼•å…¥äº†ä¸€äº›æ–°çš„çŸ¥è¯†ç‚¹ï¼š

``` rust
// main.rs
use std::io;

fn main() {
    println!("Guess the number!");
    println!("Please input your guess.");

    let mut guess = String::new();
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
    println!("Your guessd is: {}", guess);
}
```

é»˜è®¤æƒ…å†µä¸‹ rust åªå¼•å…¥äº†å°‘é‡çš„ç±»å‹ï¼Œä¸ºäº†è·å–ç”¨æˆ·çš„è¾“å…¥è¾“å‡ºï¼Œéœ€è¦ä½¿ç”¨ use å¼•å…¥ std::io åˆ°ä½œç”¨åŸŸä¸­ï¼Œstd è¡¨ç¤º io æ˜¯æ ‡å‡†åº“çš„ä¸€éƒ¨åˆ†ã€‚

rust ä½¿ç”¨ let å…³é”®å­—åˆ›å»ºå˜é‡å’Œå¸¸é‡ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œrust æä¾›çš„å˜é‡æ˜¯ä¸å¯å˜çš„ï¼Œè‹¥éœ€è¦å¯å˜çš„å˜é‡éœ€è¦æ˜¾å¼ä½¿ç”¨ mut å…³é”®å­—æŒ‡å‡ºã€‚

``` rust
let foo = bar;     // immutable
let mut foo = bar; // mutable
```

let mut guess = String::new() è¯­å¥ä¸­ï¼Œguess å˜é‡ç»‘å®šåˆ° String::new() çš„è¿”å›ç»“æœï¼ŒString æ˜¯æ ‡å‡†åº“æä¾›çš„å¯å˜çš„ã€utf-8 æ ¼å¼çš„å­—ç¬¦ä¸²ç±»å‹ï¼Œ"::" è¡¨ç¤º new æ˜¯ String çš„ä¸€ä¸ªå…³è”å‡½æ•°ï¼Œå…¶æ— éœ€å®ä¾‹åŒ–å³å¯è°ƒç”¨ï¼Œç±»ä¼¼å…¶ä»–è¯­è¨€çš„é™æ€å‡½æ•°ã€‚new() æ–¹æ³•å°†åˆ›å»ºä¸€ä¸ªæ–°çš„ String ç©ºå®ä¾‹ã€‚

ä¸ºäº†å’Œç”¨æˆ·äº¤äº’ï¼Œä½¿ç”¨äº† std::ioï¼Œio::stdin() å°†è¿”å› std::io::Stdinï¼Œå³æ ‡å‡† I/O çš„ä¸€ä¸ªå¥æŸ„ï¼Œread_line å‡½æ•°å°†ä»ç»ˆç«¯è·å–ç”¨æˆ·è¾“å…¥ï¼Œå¹¶**è¿½åŠ **åˆ° guess å­—ç¬¦ä¸²å˜é‡åï¼Œå› æ­¤ï¼Œguess å¿…é¡»æ˜¯ä¸€ä¸ªå¯å˜å¯¹è±¡ã€‚"&" è¡¨ç¤ºä½¿ç”¨äº†å¯¹è±¡çš„å¼•ç”¨ï¼Œä½¿ç”¨å¼•ç”¨ä»¥é¿å…å¯¹å˜é‡çš„é‡å¤æ‹·è´ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå¼•ç”¨å’Œå˜é‡ç›¸åŒï¼Œå‡ä¸ºä¸å¯å˜ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ "&mut guess" è€Œé "&guess"ã€‚

'.expect("...")' å¯¹å‡½æ•°è¿”å›ç»“æœçš„æ½œåœ¨é£é™©è¿›è¡Œå¤„ç†ã€‚read_line å‡½æ•°è¯»å–ç”¨æˆ·è¾“å…¥ï¼Œå¹¶è¿”å›ä¸€ä¸ª io::Result ç±»å‹çš„æ•°æ®ã€‚Result ç±»å‹å¹¿æ³›å­˜åœ¨äº rust çš„å¤šä¸ªæ¨¡å—ä¸­ï¼Œå…¶å®è´¨æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œå…¶å€¼åŒ…æ‹¬ Errã€Okï¼Œè‹¥å¾—åˆ°çš„è¿”å›å€¼ä¸º Errï¼Œåˆ™å°†å¯¼è‡´ç¨‹åº crash å¹¶ä½¿ç”¨expectæä¾›çš„ä¿¡æ¯ï¼Œè‹¥å¾—åˆ° Okï¼Œåˆ™è¿”å›å…¶æºå¸¦çš„æ•°å€¼ã€‚è‹¥ä¸ºä½¿ç”¨ expect å‡½æ•°ï¼Œåœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ï¼Œrust å°†ç»™å‡ºè­¦å‘Šã€‚

rust ä½¿ç”¨ "{}" ä½œä¸ºç¨‹åºæ ¼å¼åŒ–è¾“å‡ºçš„å ä½ç¬¦ï¼š

``` rust
let x = 5;
let y = 6;
println!("x={}, y={}", x, y);
```

å…¶æ¬¡ï¼Œä¸ºäº†å®ŒæˆçŒœæ•°æ¸¸æˆï¼Œéœ€è¦å­¦ä¹ å¦‚ä½•è·å¾—éšæœºæ•°ã€‚rust çš„æ ‡å‡†åº“ä¸­å¹¶ä¸æä¾›éšæœºæ•°çš„æ”¯æŒï¼Œä¸è¿‡å…¶æ‹¥æœ‰ä¸°å¯Œçš„ crates ä½œä¸ºè¯­è¨€çš„æ‰©å±•æ”¯æŒï¼Œä¿®æ”¹ Cargo.toml å¼•å…¥ rand æ¨¡å—çš„ä¾èµ–

```
[dependencies]
rand = "0.8.3"
```

cargo åœ¨æ‰§è¡Œ build æ—¶å°†è‡ªåŠ¨æ„å»ºå¯¹åº”çš„ä¾èµ–å…³ç³»ï¼ŒåŒ…æ‹¬ rand æ¨¡å—æœ¬èº«çš„ä¾èµ–å†…å®¹ã€‚å…¶ç‰ˆæœ¬å·ç¬¦åˆ SemVer æ ‡å‡†ï¼Œè¡¨æ˜é¡¹ç›®ä¾èµ–çš„ rand æ¨¡å—éœ€è¦åœ¨ 0.8.3 åˆ° 0.9.0 ä¹‹é—´ï¼Œé«˜äºæˆ–ç­‰äº 0.9.0 åˆ™æ— æ³•ä¿è¯ api çš„ä¸€è‡´æ€§ã€‚cargo build å°†åªå¯¹ç¨‹åºä¿®æ”¹å†…å®¹è¿›è¡Œç¼–è¯‘ï¼Œå¼•å…¥çš„ crates åªä¼šç¼–è¯‘ä¸€æ¬¡ã€‚Cargo.lock æŒ‡æ˜äº†ä¾èµ–é¡¹ç›®çš„ç‰ˆæœ¬ï¼Œä»è€Œä¿è¯ä»»ä½•æ—¶é—´ã€ä»»ä½•äººéƒ½å¯ä»¥æˆåŠŸç¼–è¯‘è¿™ä»½é¡¹ç›®ä»£ç ã€‚åœ¨ crates æœ‰å¯å‡çº§çš„ç‰ˆæœ¬æ—¶ï¼Œè¯·åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹æ‰§è¡Œ cargo updateã€‚è‹¥éœ€è¦å¤§ç‰ˆæœ¬çš„æ›´æ–°ï¼Œè¯·ä¿®æ”¹ Cargo.toml æ–‡ä»¶ã€‚

ä¸‹é¢ä½¿ç”¨ rand ç”Ÿæˆ 1 åˆ° 100 çš„éšæœºæ•°ï¼š

``` rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
}
```

Rng trait ä¸­å®šä¹‰äº†å¾ˆå¤šå…³äºéšæœºæ•°ç”Ÿæˆæ–¹æ³•çš„æ¥å£ï¼Œä¸ºäº†ä½¿ç”¨è¿™äº›æ–¹æ³•ï¼Œé¦–å…ˆä½¿ç”¨ use å¼•å…¥ã€‚rand::thread_rng æä¾›äº†éšæœºæ•°ç”Ÿæˆå™¨ï¼šåœ¨å½“å‰çº¿ç¨‹ä¸­å¹¶ä½¿ç”¨ç³»ç»Ÿç§å­è¿è¡Œã€‚åˆ©ç”¨ gen_range ç”Ÿæˆ 1 åˆ° 100 ä¹‹é—´çš„éšæœºæ•°ï¼ŒèŒƒå›´å·¦é—­å³å¼€ï¼Œå½“ç„¶ï¼Œä¹Ÿå¯ä½¿ç”¨ "1..=100" ä½œä¸ºå·¦é—­å³é—­çš„å‚æ•°ã€‚

å½“ä½¿ç”¨ä¸€ä¸ªæ–°çš„ crate æ—¶ï¼Œå¯ä»¥åœ¨é¡¹ç›®ç›®å½•ä¸­ä½¿ç”¨å‘½ä»¤ cargo doc --open æŸ¥çœ‹å½“å‰é¡¹ç›®ä¸­æ‰€æœ‰æ¨¡å—çš„æ–‡æ¡£ã€‚

æ¥ä¸‹æ¥ï¼Œéœ€è¦å¯¹ç”¨æˆ·è¾“å…¥å’Œéšæœºæ•°å­—è¿›è¡Œæ¯”è¾ƒï¼š

``` rust
use std::cmp::Ordering;

fn main() {
    let guess = 2;
    let secret_number = 3;
    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => {
            println!("You win!")
            // more
        },
    }
}

```

ä¸ºäº†è¿›è¡Œç»“æœçš„æ¯”è¾ƒï¼Œéœ€è¦å¼•å…¥ Orderingï¼Œç±»ä¼¼äº Resultï¼Œå…¶äº¦ä¸ºæšä¸¾ç±»å‹ï¼Œä¸è¿‡å…¶å†…åŒ…å« Greaterã€Lessã€Equal ä¸‰ä¸ªå…ƒç´ ã€‚ä½¿ç”¨å˜é‡çš„å†…è”æ–¹æ³• cmp å¯¹ä¸¤ä¸ªæ•°å€¼ç»“æœè¿›è¡Œæ¯”è¾ƒï¼Œå…¶å°†è¿”å›ä¸€ä¸ª Ordering ç±»å‹çš„ç»“æœï¼Œä½¿ç”¨ match å¯¹è¯¥ç»“æœè¿›è¡Œåˆ†æ”¯æ¯”è¾ƒï¼Œä¾æ¬¡æ¯”è¾ƒ 3 ç§ Ordering çš„å¯èƒ½å€¼ï¼Œå½“åŒ¹é…æˆåŠŸåˆ™æ‰§è¡Œ => åçš„è¯­å¥ï¼Œå¯ä»¥ä½¿ç”¨ "{}" æ‰§è¡Œå¤šæ¡è¯­å¥ã€‚

ä¸è¿‡ cmp å‡½æ•°éœ€è¦æ¯”è¾ƒç›¸åŒçš„ç±»å‹ï¼Œå¦‚æ•´æ•°å’Œ string æ‰§è¡Œ cmpï¼Œå°†æ— æ³•é€šè¿‡ç¼–è¯‘ã€‚rust å†…ç½®äº†ä¸€äº›åŸºæœ¬çš„ç±»å‹ï¼Œæ¯”å¦‚æ•°å­—çš„ i32ï¼Œu32ï¼Œi64ï¼Œu64 ç­‰ï¼Œåˆ†åˆ«è¡¨ç¤ºæœ‰ç¬¦å·å’Œæ— ç¬¦å·çš„ 32 ä½å’Œ 64 ä½æ•´å½¢æ•°æ®ï¼Œåœ¨å®šä¹‰å˜é‡æ—¶å¯æ˜ç¡®æŒ‡å‡ºï¼š

``` rust
{
    let secret_number = 3;
    let mut guess = String::new();
    let guess: u32 = guess.trim().parse().expect("Please input number!");
    // get input from terminal here
    match guess.cmp(secret_number) {
        // arms here
    }
}
```

åœ¨ rust ä¸­ï¼Œå¯ä»¥é‡å¤å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œè¿™åœ¨å°†ä¸€ä¸ªæ•°æ®ç±»å‹è½¬æ¢ä¸ºå…¶ä»–æ•°æ®ç±»å‹çš„æƒ…å†µä¸‹å¾ˆæœ‰ç”¨ï¼Œæ— éœ€å®šä¹‰ä¸¤ä¸ªä¸åŒç±»å‹çš„ç›¸åŒå˜é‡ã€‚trim å‡½æ•°å°†å»é™¤å­—ç¬¦ä¸²å‰åçš„ç©ºç™½å­—ç¬¦ï¼Œparse å‡½æ•°åˆ™è§£æå­—ç¬¦ä¸²å¹¶è½¬æ¢ä¸ºæ•°å­—ï¼Œå®šä¹‰å˜é‡æ—¶é€šè¿‡ ": u32" æŒ‡æ˜ guess ä¸ºæ— ç¬¦å·32ä½æ•´å‹æ•°æ®ï¼Œå› æ­¤ï¼Œrust åœ¨æ‰§è¡Œ cmp æ—¶ï¼Œå³å¯éšå¼æ¨æ–­ secret_number ä¸ºä¸€ä¸ª u32 ç±»å‹æ•°æ®ã€‚

rust å¯ä»¥ä½¿ç”¨ loop è¿›è¡Œå¾ªç¯ï¼Œå¹¶ä½¿ç”¨ break å’Œ continue å®ç°å¾ªç¯çš„è·³è½¬ã€‚

``` rust
fn main() {
    loop {
        // loop body
        // break;
        // continue;
    }
}
```

æœ€åï¼Œå¯ä»¥ä¸ºæ ‡å‡† io æä¾›æ›´å¥å£®çš„é”™è¯¯å¤„ç†æ–¹å¼:

``` rust
fn main() {
    loop {
        // ...
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(\_) => continue,
        };
        // ...
    }
}
```

Ok(num) åŒ¹é…é™„å¸¦ä¸€ä¸ªå‚æ•°çš„ Ok æšä¸¾å€¼ï¼ŒErr(\_) åŒ¹é…é™„å¸¦ä»»æ„å‚æ•°çš„é”™è¯¯ç»“æœã€‚å®Œæ•´ç¨‹åºå¦‚ä¸‹ï¼š

``` rust
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        // let guess: u32 = guess.trim().parse()
        //                        .expect("Please input a number!");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("Your guessd is: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too Big!"),
            Ordering::Equal => { 
                println!("You win!");
                break;
            },
        }
    }
}
```

# ä¸‰ã€è¯­è¨€åŸºç¡€

åœ¨è¿™ä¸€éƒ¨åˆ†ï¼Œä¸»è¦å­¦ä¹  rust è¯­è¨€çš„åŸºç¡€çŸ¥è¯†ï¼Œå¦‚å˜é‡ã€æ•°æ®ç±»å‹ã€å‡½æ•°ã€æ³¨é‡Šä»¥åŠæ§åˆ¶æµã€‚

å­¦ä¹ ä¹‹å‰ï¼Œè¯·é¦–å…ˆ[äº†è§£ rust ä¿ç•™çš„å…³é”®å­—](https://doc.rust-lang.org/book/appendix-01-keywords.html)ï¼Œåœ¨åç»­ç¨‹åºçš„ç¼–å†™è¿‡ç¨‹ä¸­ä»¥é¿å…ä½¿ç”¨è¿™äº›å…³é”®å­—æ¥å®šä¹‰è‡ªå·±çš„åç§°ã€‚

## å˜é‡åŠå…¶å¯å˜æ€§

æ­£å¦‚ç¬¬äºŒç« æåˆ°çš„ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œrust å®šä¹‰çš„å˜é‡éƒ½æ˜¯ä¸å¯å˜çš„ï¼Œè¿™ä¸å…¶ä»–è¯­è¨€æœ‰æ‰€åŒºåˆ«ï¼Œä¹ŸåŒæ ·å› æ­¤ä½¿ rust æ›´å…·å®‰å…¨æ€§å’Œå¹¶å‘æ€§ã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥æ ¹æ®éœ€è¦ï¼Œä»¤å®šä¹‰çš„å˜é‡å¯å˜ã€‚

å¦‚ä¹‹å‰æ‰€æåˆ°çš„ï¼Œrust ä½¿ç”¨ let æ¥å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œå¦‚æœè¯¥å˜é‡æ˜¯ä¸å¯å˜çš„ï¼Œä¸€æ—¦è¿™ä¸ªå˜é‡ç»‘å®šåˆ°æŸä¸ªå€¼åï¼Œå…¶å€¼å°†ä¸èƒ½è¢«æ”¹å˜ï¼Œå½“å°è¯•ç¼–è¯‘å¦‚ä¸‹çš„ç¨‹åºæ—¶ï¼Œå°†ä¼šå¤±è´¥ï¼Œå¹¶ç»™å‡º " cannot assign twice to immutable variable" çš„è­¦å‘Šã€‚

``` rust
fn main() {
    let x = 5;
    println!("x is {}", x);
    x = 6;
    println!("x is {}", x);
}
```

rust ä¿è¯äº†å£°æ˜ä¸ºä¸å¯å˜çš„å˜é‡ä¸€æ—¦ç»‘å®šäº†æ•°å€¼åå°†æ°¸è¿œä¸å†æ”¹å˜ï¼Œå¯¹äºè¿™ç§å˜é‡ï¼Œæ— éœ€è€ƒè™‘å…¶åœ¨ä½•æ—¶ã€ä½•å¤„ä»¥åŠæ€æ ·å‘ç”Ÿæ”¹å˜ã€‚

å¦‚æœéœ€è¦å¯å˜çš„å˜é‡ï¼Œéœ€è¦ä½¿ç”¨ mut å…³é”®å­—æ˜¾å¼å£°æ˜ï¼Œåªéœ€å°† mut æ”¾åœ¨å˜é‡åå‰å³å¯ã€‚æ­¤æ—¶æˆ‘ä»¬ä¿®æ”¹ä¸Šè¿°ç¨‹åºå³å¯æ­£å¸¸ç¼–è¯‘å¹¶è¿è¡Œï¼Œå› ä¸ºæˆ‘ä»¬æ“çºµçš„æ˜¯ä¸€ä¸ªå¯å˜çš„å˜é‡ã€‚ä½¿ç”¨å˜é‡çš„å¯å˜æ€§æ˜¯å¯¹é”™è¯¯å’Œæ•ˆç‡ç­‰é—®é¢˜çš„æƒè¡¡å’ŒæŠ˜ä¸­ï¼Œä¸å¯å˜è¡Œæä¾›äº†æ›´é«˜çš„å®‰å…¨æ€§ï¼Œè€Œå¯å˜å˜é‡åˆ™å¯èƒ½é¿å…äº†æ–°å˜é‡çš„åå¤åˆ›å»ºå’Œæ‹·è´ç­‰ã€‚

``` rust
fn main() {
    // let x = 5;
    let mut x = 5;
    println!("x is {}", x);
    x = 6;
    println!("x is {}", x);
}
```

åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œæœ‰å¸¸é‡ï¼ˆconstantï¼‰çš„æ¦‚å¿µï¼Œç±»ä¼¼äº rust çš„ä¸å¯å˜å˜é‡ï¼Œä½†æ˜¯ rust çš„å¸¸é‡å’Œå˜é‡å­˜åœ¨ä¸€äº›åŒºåˆ«ï¼š

- ä¸å…è®¸å°† mut å’Œå¸¸é‡ä¸€èµ·ä½¿ç”¨ï¼Œå› ä¸ºå¸¸é‡æ˜¯æ°¸è¿œçš„æ’å€¼ï¼Œè€Œéé»˜è®¤ä¸ºæ’å€¼ï¼›
- å½“ä½¿ç”¨ const è€Œä¸æ˜¯ let æ¥å£°æ˜ä¸€ä¸ªå¸¸é‡æ—¶ï¼Œå¿…é¡»æŒ‡æ˜æ•°æ®ç±»å‹ï¼›
- const å¯ä»¥å£°æ˜åœ¨ä»»æ„ä½œç”¨åŸŸä¸­ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨ï¼Œè€Œ let æ— æ³•å£°æ˜åœ¨å…¨å±€ä½œç”¨åŸŸä¸­ï¼›
- å¸¸é‡çš„å€¼åªèƒ½æ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œä¸èƒ½æ˜¯ä»»æ„ä¸€ä¸ªè¿è¡Œæ—¶è·å–çš„å€¼ã€‚

ä¸‹é¢å£°æ˜äº†ä¸¤ä¸ªå¸¸é‡ï¼Œrust å»ºè®®ä½¿ç”¨å¤§å†™ä½œä¸ºå¸¸é‡çš„åç§°ï¼Œå¦åˆ™å°†åœ¨ç¼–è¯‘å™¨ç»™å‡ºè­¦å‘Šã€‚

``` rust
const MAX: u32 = 123;
fn main() {
    let x = 5;
    const MIN: u32 = 123;
    println!("x is {}, MAX is {}, MIN is {}", x, MAX, MIN);
}
```

é™¤å˜é‡ä¸å¯å˜çš„ç‰¹æ€§å¤–ï¼Œå˜é‡ä¸å…¶ä»–è¯­è¨€ä»æœ‰ä¸€ä¸ªæ˜æ˜¾çš„ç‰¹ç‚¹ï¼šrust æ”¯æŒå¯¹å·²å®šä¹‰çš„å˜é‡è¿›è¡Œè¦†ç›–ï¼ˆå¸¸é‡ä¸å…·æœ‰è¿™æ ·çš„ç‰¹æ€§ï¼Œrust å°†å…¶ç§°ä¸º Shadowingï¼‰ï¼Œå³åœ¨å·²å®šä¹‰çš„å˜é‡åï¼Œå¯ä»¥é‡æ–°å®šä¹‰ä¸€ä¸ªåŒåçš„å˜é‡æ¥è¦†ç›–ï¼Œå¦‚ä¸‹é¢ç»™å‡ºçš„ç¨‹åºï¼Œæœ€å x çš„å€¼ä¸º 7ã€‚

``` rust
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x + 1;
    println!("x is {}", x);
}
```

Shadowing å’Œ mut æ˜¯ä¸åŒçš„ï¼Œè‹¥æ²¡æœ‰ let å…³é”®å­—ï¼Œè¿™ç§ "x = x + 1" å¯¹å˜é‡çš„æ“ä½œæ˜¯ä¸å…è®¸çš„ï¼Œé€šè¿‡Shadowing å¯ä»¥å¯¹å·²æœ‰å˜é‡è¿›è¡Œä¸€äº›è½¬æ¢å¹¶å¾—åˆ°æ–°çš„ä¸å¯å˜å˜é‡ã€‚

é™¤äº†ä¸Šè¿°ç‰¹æ€§å¤–ï¼ŒShadowing ä¹Ÿå¯ä»¥å®ç°ä¸åŒç±»å‹çš„è½¬æ¢ï¼Œè¿™å’Œ mut æ˜¯ä¸åŒçš„ï¼š

``` rust
let spaces = "  ";        // String
let spaces = space.len(); // integer
```

å¦‚æœä½¿ç”¨ mut æ¥å®šä¹‰ spacesï¼Œåˆ™æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå³æˆ‘ä»¬ä¸èƒ½æ”¹å˜ mut å˜é‡åçš„ç±»å‹ã€‚

## åŸºæœ¬æ•°æ®ç±»å‹

rust æ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œåœ¨ç¼–è¯‘æœŸå¿…é¡»æ˜ç¡®å„ä¸ªå˜é‡çš„æ•°æ®ç±»å‹ã€‚æ•°æ®ç±»å‹å¯ä»¥åœ¨ä»£ç ä¸­æ˜ç¡®æŒ‡å®šï¼Œé™¤æ­¤å¤–ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä¸Šä¸‹æ–‡æ¨æ–­ã€‚å¦‚çŒœæ•°æ¸¸æˆä¸­ï¼Œå®šä¹‰ guess å¿…é¡»æŒ‡å®šå…¶ç±»å‹ä¸º "u32"ï¼Œå¦åˆ™ï¼Œparse å‡½æ•°é€šè¿‡ç¼–è¯‘ã€‚

``` rust
let guess: u32 = "42".parse().expect("Not a number!");
```

ä¸‹é¢ä»‹ç» rust æ•°æ®ç±»å‹çš„ä¸¤ä¸ªå­é›†ï¼šæ ‡é‡ç±»å‹å’Œå¤åˆç±»å‹ã€‚

### æ ‡é‡ç±»å‹

rust ä¸­çš„æ ‡é‡ç±»å‹ï¼Œå³åœ¨å…¶ä»–è¯­è¨€ä¸­å¸¸è§çš„å¦‚æ•´å‹ã€æµ®ç‚¹ç±»å‹ã€å¸ƒå°”ç±»å‹å’Œå­—ç¬¦ç±»å‹ã€‚

#### æ•´å‹

åœ¨ rust è¡¨ç¤ºæ•´å½¢çš„æ–¹æ³•ä¸º "u/iä½é•¿åº¦"ï¼Œu è¡¨ç¤ºæ— ç¬¦å·æ•°ï¼Œiè¡¨ç¤ºæœ‰ç¬¦å·æ•´æ•°ï¼ŒåŒ…æ‹¬ï¼š

| é•¿åº¦ | æœ‰ç¬¦å· | æ— ç¬¦å· |
| :-----: | :----: | :----: |
| 8-bits | i8 | u8 |
| 16-bits | i16 | u16 |
| 32-bits | i32 | u32 |
| 64-bits | i64 | u64 |
| 128-bits | i128 | u128 |
| arch | isize | usize |

å¯ä»¥ä½¿ç”¨ "i/usize" ä½¿ç”¨æ“ä½œç³»ç»Ÿæ”¯æŒçš„æ•´å½¢é•¿åº¦ï¼Œåœ¨å¯¹é›†åˆè¿›è¡Œç´¢å¼•æ—¶å¸¸å¸¸ä½¿ç”¨åˆ°è¿™ç§ç±»å‹ã€‚æ­¤å¤–ï¼Œrust æ”¯æŒå¤šç§è¿›åˆ¶çš„å­—é¢å€¼è¡¨ç¤ºï¼š

| å­—é¢å€¼ç±»å‹ | è¡¨ç¤º |
| :-----: | :----: |
| 10è¿›åˆ¶ | 123_456_789 |
| 16è¿›åˆ¶ | 0xABCD |
| 8è¿›åˆ¶ | 0o77 |
| 2è¿›åˆ¶ | 0b1111_0000 |
| å­—ç¬¦(u8) | b'A'


#### æµ®ç‚¹ç±»å‹

rust ä½¿ç”¨ f32 å’Œ f64 åˆ†åˆ«è¡¨ç¤º 32 ä½æµ®ç‚¹æ•°å’Œ 64 ä½æµ®ç‚¹æ•°ï¼Œrust é»˜è®¤ä½¿ç”¨ 64 ä½æµ®ç‚¹æ•°ã€‚

``` rust
fn main() {
    let a = 1.0;        // f64
    let x: f32 = 1.2;   // f32
    let y: f64 = 2.2;   // f64
}
```

#### æ•°å€¼æ“ä½œ

åŒæ ·ï¼Œrust ä¸ºæ•°å€¼ç±»å‹æä¾›äº†åŠ å‡ä¹˜é™¤çš„æ“ä½œç¬¦ï¼Œå…¶è®¡ç®—ç»“æœç»‘å®šåˆ°ä¸€ä¸ªå˜é‡ä¸Šï¼š

``` rust
fn main() {
    let sum = 1 + 2;
    let dif = 2 - 1;
    let mul = 1 * 2;
    let div = 2 / 1;
    let m   = 2 % 1;
}
```

#### å¸ƒå°”ç±»å‹

rust ä½¿ç”¨ trueã€false ä½œä¸ºå¸ƒå°”å€¼ bool çš„å­—é¢å€¼ï¼š

``` rust
fn main() {
    let t = true;
    let f: bool = false; // with explicit type annotation
}
```

#### å­—ç¬¦ç±»å‹

rust çš„ char ç±»å‹ä¸º 4 å­—èŠ‚çš„é•¿åº¦çš„ unicode æ”¯æŒçš„å¸¸é‡å€¼ï¼Œèƒ½å¤Ÿè¡¨ç¤ºåŒ…æ‹¬ä¸­æ–‡ã€æ—¥æ–‡ç­‰å¤šç§å­—ç¬¦ã€‚ä½¿ç”¨å•å¼•å·è¡¨ç¤ºï¼š

``` rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
```

### å¤åˆç±»å‹

rust çš„å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªæ•°å€¼é›†åˆåˆ°ä¸€ä¸ªæ•°æ®ç±»å‹ä¸­æ¥è¡¨ç¤ºï¼Œä¸»è¦æœ‰ä¸¤ç§ï¼šå…ƒç»„ï¼ˆtuplesï¼‰å’Œæ•°ç»„ï¼ˆarraysï¼‰ã€‚

#### å…ƒç»„

å…ƒç»„æ˜¯ä¸€ç§å°†å¤šç§ä¸åŒç±»å‹æ•°æ®é›†åˆåˆ°ä¸€èµ·çš„å¸¸ç”¨çš„æ–¹æ³•ï¼Œå…¶ä¸€æ—¦åˆ›å»ºï¼Œé•¿åº¦å›ºå®šä¸å¯ä¿®æ”¹ï¼Œå…ƒç»„ä½¿ç”¨åœ†æ‹¬å·è¡¨ç¤ºï¼š

``` rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

ä½¿ç”¨å…ƒç»„ï¼Œæœ‰æ–¹ä¾¿çš„æ–¹æ³•å¯¹å…¶ä¸­çš„æ¯ä¸ªå…ƒç´ è§£åŒ…ï¼š

``` rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

é™¤æ­¤ä¹‹å¤–ï¼Œå¯ä»¥é€šè¿‡å…ƒç»„ç´¢å¼•æ¥è®¿é—®å…¶ä¸­ä»»æ„å…ƒç´ ï¼Œä½¿ç”¨ "tuple.index" å®ç°ï¼Œå…¶ç´¢å¼•èŒƒå›´ä» 0 å¼€å§‹ï¼š

``` rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

#### æ•°ç»„

æ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ çš„æ•°æ®ç±»å‹å¿…é¡»ç›¸åŒï¼Œå…¶é•¿åº¦æ˜¯å›ºå®šçš„ï¼Œä½¿ç”¨æ–¹æ‹¬å·è¡¨ç¤ºï¼š

``` rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

å½“æ‰€éœ€æ•°æ®é›†åˆä¸ºç›¸åŒç±»å‹ä¸”å¸Œæœ›å°†æ•°æ®åˆ†é…åœ¨å †ä¸Šè€Œä¸æ˜¯æ ˆä¸Šæˆ–å§‹ç»ˆéœ€è¦å›ºå®šæ•°é‡çš„æ•°æ®æ—¶ï¼Œä½¿ç”¨æ•°æ®å¯èƒ½æ˜¯ä¸€ä¸ªé€‰æ‹©ï¼Œä¸è¿‡ï¼Œå…¶ä¸å¦‚ vector ï¼ˆæ ‡å‡†åº“æä¾›ï¼Œåç»­ä»‹ç»ï¼‰çµæ´»ï¼Œåè€…å¯åŠ¨æ€æ‰©å®¹ã€‚è‹¥æ— æ³•æ˜ç¡®ä½¿ç”¨æ•°ç»„æˆ– vectorï¼Œè¯·ä½¿ç”¨ vectorã€‚

å¦‚ï¼Œç¨‹åºéœ€è¦å›ºå®šçš„ä¸€äº›ä¿¡æ¯ï¼Œä½¿ç”¨ arrayï¼š

``` rust
fn main() {
    let months = ["January", "February", "March", "April", "May", "June", "July",
                "August", "September", "October", "November", "December"];
}
```

å£°æ˜æ•°ç»„æ—¶ï¼Œä¹Ÿå¯æŒ‡æ˜å…ƒç´ ç±»å‹å’Œé•¿åº¦ï¼š

``` rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

å¯ä»¥åˆ›å»ºä¸€ä¸ªæœ‰ç›¸åŒå…ƒç´ çš„æ•°ç»„ï¼š

``` rust
let a = [3; 5];
```

a çš„å€¼ä¸º [3, 3, 3, 3, 3]ã€‚

æ•°ç»„çš„å…ƒç´ å€¼å¯ä»¥ä½¿ç”¨ç´¢å¼•è®¿é—®ï¼š

``` rust
let a = [1, 2, 3, 4, 5];
let first = a[0];
let end   = a[4];
```

åœ¨ç¨‹åºä¸­ï¼Œå¦‚æœæ½œåœ¨ç´¢å¼•è¶Šç•Œï¼Œç¨‹åºæ˜¯å¯ä»¥ç¼–è¯‘æˆåŠŸçš„ï¼Œä½†å½“è¿è¡Œæ—¶é‡åˆ°è¶Šç•Œé—®é¢˜ï¼Œå°†å¯¼è‡´ç¨‹åºè¿è¡Œå¤±è´¥ã€‚åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œå½“é‡åˆ°è¶Šç•Œé—®é¢˜æ—¶ï¼Œç¨‹åºä¼šç»§ç»­è¿è¡Œï¼Œè€Œ rust å°†é˜»æ­¢è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œé€šè¿‡ç«‹å³é€€å‡ºæ¥é˜»æ­¢å¯¹éæ³•å†…å­˜çš„è®¿é—®ï¼Œè¿™é‡Œåˆ©ç”¨æ‰€å­¦çš„è¯­è¨€ç‰¹æ€§æä¾›äº†ä¾‹å­

``` rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("input index:");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Faile to read line");

    let index : usize = index.trim().parse().expect("Index not a number"); 

    let element = a[index];

    println!("value is {}, index is {}", element, index);
}
```

## å‡½æ•°

### å‡½æ•°å®šä¹‰å’Œä¼ å‚

rust ä½¿ç”¨ fn å…³é”®å­—æ¥å®šä¹‰å‡½æ•°ï¼Œå¦‚æ‰€è§çš„ main å‡½æ•°ï¼Œæˆ‘ä»¬åŒæ ·å¯ä»¥å®šä¹‰å…¶ä»–å‡½æ•°ï¼ŒåŒ…æ‹¬æ— å‚æ•°å‡½æ•°ã€æœ‰å‚æ•°å‡½æ•°ç­‰ï¼Œå‡½æ•°å‚æ•°å¿…é¡»æŒ‡æ˜æ•°æ®ç±»å‹ï¼Œå½“ç„¶å„ä¸ªå‚æ•°å¯ä»¥æœ‰å„è‡ªçš„ç±»å‹ã€‚

``` rust
fn main() {
    test();
    test_args(x: i32, y: i32);
}

fn test() {
    println!("This is test fn");
}

fn test_args(x: i32, y: i32) {
    println!("The arg is x:{}, y:{}", x, y);
}
```

### statements å’Œ expressions

å‡½æ•°ä½“ç”± statements å’Œ expressions ç»„æˆï¼Œexpressions æ˜¯ statement çš„ä¸€éƒ¨åˆ†ã€‚rust æ˜¯åŸºäºè¡¨è¾¾å¼çš„è¯­è¨€ ï¼ˆ expression-basedï¼‰ã€‚statement æ‰§è¡Œä¸€äº›åŠ¨ä½œä½†æ˜¯ä¸è¿”å›å€¼ï¼Œexpression æ€»æ˜¯èƒ½å¤Ÿæ¨æ–­å‡ºç»“æœã€‚å¦‚ let è¯­å¥ä¸ºä¸€ä¸ª statementï¼š

``` rust
fn main() {
    let x = 6;
}
```

å¦‚æœè¯•å›¾å°† let è¯­å¥ç»‘å®šåˆ°ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå°†æ— æ³•ç¼–è¯‘ï¼Œå› ä¸º let è¯­å¥ä¸èƒ½è¿”å›å€¼ï¼Œå› æ­¤ä¹Ÿä¸èƒ½ç»‘å®šæ–°çš„å˜é‡ã€‚å› æ­¤ï¼Œåœ¨ rust ä¸­ä¸ç±»ä¼¼äº C è¯­è¨€çš„ x=y=1 çš„è¡Œä¸ºä¸åŒã€‚

``` rust
fn main() {
    let y = (let x = 6); // comile error
}
```

ä»¥ä¸Šçš„å‡½æ•°å®šä¹‰ä¹Ÿæ˜¯ä¸€ä¸ª statementã€‚è€Œè®¡ç®—å¹¶å¯å¾—åˆ°ç»“æœçš„è¡¨è¾¾å¼ç»„æˆäº† rust ç¨‹åºçš„ç»å¤§éƒ¨åˆ†ï¼Œè¯¸å¦‚ 5 + 6ã€100ã€è°ƒç”¨å‡½æ•°ã€è°ƒç”¨å®ç­‰ä»¥åŠä½¿ç”¨ "{}" åŒ…è£¹çš„å¤šæ¡è¯­å¥ï¼Œéƒ½æ˜¯æˆ–èƒ½å¤Ÿæˆä¸ºè¡¨è¾¾å¼ï¼Œè¡¨è¾¾å¼çš„ç»“å°¾ä¸åŒ…å«åˆ†å·ï¼Œå¦åˆ™å…¶å°†è½¬æ¢ä¸º statementï¼Œå¹¶ä¸”å°†ä¸ä¼šè¿”å›å€¼ã€‚

``` rust
fn main() {
    let x = 1;
    let y = {
        let x = 10;
        x + 1
    }; // ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ³¨æ„ x + 1 åæ— åˆ†å·ç»“å°¾ï¼Œæ­¤ expression ç»“æœä¸º 11
    println!("x out is {}", x);
    println!("y is {}", y);
}
```

### å‡½æ•°è¿”å›å€¼

åœ¨ rust ä¸­ï¼Œ ä½¿ç”¨ "->" æ¥æŒ‡æ˜è¿”å›å€¼ç±»å‹ï¼Œæ•´ä¸ªå‡½æ•°ä½“å’Œ "{}" åŒ…è£¹çš„è¡¨è¾¾å¼æ˜¯åŒä¹‰çš„ã€‚å½“ç„¶ï¼Œå‡½æ•°å¯ä»¥ä½¿ç”¨ return å…³é”®å­—æå‰è¿”å›ç»“æœï¼Œå¤§å¤šæ•°å‡½æ•°éšå¼è¿”å›æœ€åä¸€ä¸ªè¡¨è¾¾å¼ã€‚

``` rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

å¦‚æœå‡½æ•°çš„æœ€åä¸€ä¸ªè¯­å¥åŠ ä¸Šäº†åˆ†å·ï¼Œä¸”æŒ‡æ˜å‡½æ•°éœ€è¦è¿”å›å€¼æˆ–éœ€è¦ä½¿ç”¨å®ƒçš„è¿”å›å€¼ï¼Œæ­¤æ—¶å°†æ— æ³•ç¼–è¯‘ï¼Œå› ä¸ºç°åœ¨ expression å› ä¸ºåˆ†å·å˜æˆäº† statementã€‚

## ç¨‹åºæ³¨é‡Š

æ”¯æŒ "//" çš„è¡Œæ³¨é‡Šå’Œæ–‡æ¡£æ³¨é‡Šï¼ˆåç»­ç« èŠ‚ä¸­ä»‹ç»ï¼‰ã€‚

## æ§åˆ¶æµ

### åˆ†æ”¯

ä½¿ç”¨ if else åˆ†æ”¯ï¼Œå½“ if åçš„æ¡ä»¶ä¸º trueï¼Œå°†æ‰§è¡Œå…¶å "{}" åŒ…è£¹çš„è¯­å¥ï¼Œæˆ–ç§° armsã€‚

``` rust
fn main() {
    let x = 7;
    if x > 5 {
        println!("x > 5");
    } else {
        println!("x <= 5");
    }
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œrust ä¸­ï¼Œif çš„æ¡ä»¶**å¿…é¡»æ˜¾å¼ä¸º bool ç±»å‹**ï¼Œå¦åˆ™ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼Œè¿™ä¸ C çš„éšå¼è½¬æ¢ä¸åŒã€‚

``` rust
fn main() {
    let y = 1;
    if y {
        println!("y is not 0");
    }
} // ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼Œä¸å­˜åœ¨åˆ° bool çš„éšå¼è½¬æ¢ã€‚
```

å½“å­˜åœ¨å¤šä¸ªæ¡ä»¶çŠ¶æ€æ—¶ï¼Œä½¿ç”¨ else if è¯­å¥å¤„ç†ï¼š

``` rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

å½“ä»£ç å­˜åœ¨è¿‡å¤šçš„ else if éœ€è¦è¿›è¡Œé‡æ„ï¼Œåç»­å°†ä»‹ç» match æ¥åº”å¯¹è¿™ç§çŠ¶å†µã€‚

### è¡¨è¾¾å¼ä¸­çš„åˆ†æ”¯

``` rust
fn main() {
    let z = if y { 199 } else { 299 };
    println!("z is {}", z);
}
```

éœ€è¦æ³¨æ„ï¼Œå„ä¸ª arms çš„å€¼çš„ç±»å‹å¿…é¡»ç›¸åŒï¼Œå¦åˆ™æ— æ³•ç¼–è¯‘ï¼Œrust å¿…é¡»åœ¨ç¼–è¯‘å™¨æ˜ç¡®å„ä¸ªå˜é‡çš„ç±»å‹ã€‚

### å¾ªç¯

ä½¿ç”¨ loop æ‰§è¡Œå¾ªç¯æ“ä½œï¼Œé…åˆ break å’Œ continue æ¥å®ç°å¾ªç¯å†…å¤æ‚çš„è·³è½¬ã€‚

``` rust
fun main() {
    loop {
        println!("again");
    }
}
```

ä¸ c è¯­è¨€ä¸åŒçš„ï¼Œrust çš„å¾ªç¯ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼ˆexpressionï¼‰ï¼Œå³å…¶å¯ä»¥è¿”å›å€¼ï¼š

``` rust
fn main() {
    let mut counter = 1;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("result is {}", result); // result = 20
}
```

### å¸¦æœ‰æ¡ä»¶çš„å¾ªç¯

å’Œå…¶ä»–è¯­è¨€ç±»ä¼¼ï¼Œrust æä¾›äº†å¸¦æœ‰æ¡ä»¶çš„ while å¾ªç¯ï¼Œå…¶è¡Œä¸ºå’Œå…¶ä»–è¯­è¨€ç±»ä¼¼ï¼š

``` rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }
    println!("LIFTOFF!!!");
}
```

### èŒƒå›´for

å½“éå†ä¸€ä¸ªé›†åˆæ—¶ï¼Œfor å¾ªç¯æ˜¯ä¸€ä¸ªæ–¹ä¾¿çš„é€‰æ‹©ï¼š

``` rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

å¦‚ä½¿ç”¨ for é€†åºæ‰“å°å¾— 3ã€2ã€1ï¼š

``` rust
for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
```


# å››ã€æ‰€æœ‰æƒï¼ˆownershipï¼‰

æ‰€æœ‰æƒæ˜¯ rust è¯­è¨€çš„é‡è¦æ¦‚å¿µï¼Œå…¶ä½¿ rust åœ¨æ²¡æœ‰åƒåœ¾å›æ”¶çš„æ¦‚å¿µä¸‹ä»ç„¶ä¿è¯äº†å†…å­˜å®‰å…¨ã€‚

## æ¦‚å¿µ

ç»§ç»­å­¦ä¹  rust ä¹‹å‰ï¼Œéœ€è¦äº†è§£æ‰€æœ‰æƒçš„æ¦‚å¿µã€‚å¯¹äºåŒ…å« GC çš„è¯­è¨€ï¼Œä½¿ç”¨è€…æ— éœ€æ‹…å¿§å†…å­˜çš„ä½¿ç”¨å’Œé‡Šæ”¾ï¼Œå¯¹äºç±»ä¼¼äº C çš„è¯­è¨€ï¼Œä½¿ç”¨è€…åˆ™å¿…é¡»æ˜ç¡®åœ¨åŠ¨æ€åˆ†é…çš„å†…å­˜æ— ç”¨æ—¶æ˜¾å¼é‡Šæ”¾ã€‚è€Œ rust åˆ™ä½¿ç”¨äº†å¦ä¸€ç§æ–¹æ³•ï¼šå…¶ä½¿ç”¨ä¸€ç³»åˆ—çš„è§„åˆ™åœ¨ç¼–è¯‘æœŸå°±æ˜ç¡®äº†å†…å­˜çš„æ‰€æœ‰æƒï¼Œæ‰€æœ‰æƒçš„ç‰¹æ€§ä¸ä¼šåœ¨è¿è¡Œæ—¶æ‹–æ…¢ç¨‹åºçš„æ•ˆç‡ã€‚

> **å †å’Œæ ˆ**
>
> å­˜å‚¨åœ¨æ ˆä¸Šçš„æ•°æ®å¿…é¡»åœ¨ç¼–è¯‘å™¨æ˜ç¡®äº†ä½¿ç”¨å†…å­˜çš„å°ºå¯¸ï¼Œå¯¹äºè¿è¡ŒæœŸæ‰èƒ½ç¡®å®šå†…å­˜çš„å˜é‡ï¼Œåˆ™åˆ†é…åœ¨å †ä¸Šã€‚å¯¹äºå †å’Œæ ˆä¸­çš„å˜é‡çš„ä½¿ç”¨ï¼Œå‰è€…çš„æ•ˆç‡æ˜æ˜¾ä½äºåè€…ï¼Œå› ä¸ºå‰è€…ä¼´éšäº†å†…å­˜åˆ†é…å™¨åˆ†é…å†…å­˜ç­‰ä¸€ç³»åˆ—çš„å¤æ‚æ“ä½œã€‚å¯¹äºè¿½è¸ªå˜é‡åˆ°åº•åˆ†é…åœ¨å †æˆ–æ ˆã€å‡å°‘å †ä¸­é‡å¤æ•°æ®ã€åŠæ—¶é‡Šæ”¾ä¸å†ä½¿ç”¨çš„å†…å­˜ç­‰ï¼Œéƒ½å±äºæ‰€æœ‰æƒé—®é¢˜ã€‚

### æ‰€æœ‰æƒè§„åˆ™

rust æ‰€æœ‰æƒçš„åŸºæœ¬è§„åˆ™å¦‚ä¸‹ï¼š

- æ¯ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ä½œä¸ºå®ƒçš„æ‹¥æœ‰è€…ï¼ˆownerï¼‰;
- æ¯ä¸€ä¸ªå€¼åªèƒ½æœ‰ä¸€ä¸ª ownerï¼›
- å½“ owner å˜é‡ç¦»å¼€å…¶ä½œç”¨åŸŸï¼ˆscopeï¼‰ï¼Œè¯¥å€¼å°†è¢«ä¸¢å¼ƒï¼ˆdropï¼‰ï¼›

### å˜é‡ä½œç”¨åŸŸ

æ­¤éƒ¨åˆ†å¹¶é rust ç‹¬æœ‰çš„æ¦‚å¿µï¼Œå…¶ä¸ C è¯­è¨€ä½œç”¨åŸŸçš„æ¦‚å¿µåŸºæœ¬ç›¸åŒï¼Œå˜é‡åœ¨åˆ›å»ºåç”Ÿæ•ˆï¼Œç¦»å¼€å…¶æ‰€åœ¨çš„ä½œç”¨åŸŸå¤±æ•ˆï¼š

``` rust
{                      // s is not valid here, itâ€™s not yet declared
    let s = "hello";   // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid
```

### String ç±»å‹

ä¸ºäº†è¿›ä¸€æ­¥è¯´æ˜ä½œç”¨åŸŸçš„æ¦‚å¿µï¼Œæ­¤å¤„å¼•å…¥äº†æ›´å¤æ‚çš„æ•°æ®ç±»å‹ã€‚å‰é¢æåˆ°çš„æ•´å‹ç­‰æ•°æ®ç±»å‹ï¼Œå‡åˆ†é…åœ¨æ ˆä¸­ï¼ŒString ç±»å‹åˆ™æ˜¯åˆ†é…åœ¨å †ä¸Šçš„ä¸€ä¸ªä¾‹å­ã€‚ä½¿ç”¨ String çš„ from å‡½æ•°åˆ›å»ºä¸€ä¸ªåˆå§‹åŒ–çš„å­—ç¬¦ä¸²ï¼Œå¹¶ä½¿ç”¨ push_str æ¥è¿½åŠ ã€‚å½“ä½¿ç”¨è°ƒç”¨ from å‡½æ•°æ—¶ï¼Œrust å°†åœ¨å †ä¸Šåˆ†é…å†…å­˜å¹¶å°†ä¸€ä¸ªå­—æ¯ä¸²å­—é¢å€¼èµ‹äºˆè¯¥å˜é‡ï¼Œå½“å­—ç¬¦ä¸²å˜é‡ç¦»å¼€å…¶ä½œç”¨åŸŸï¼Œä¸€ä¸ªç±»ä¼¼äº free çš„åŠ¨ä½œåˆ™å¿…é¡»ä¸”åªèƒ½è¢«è‡ªåŠ¨æ‰§è¡Œä¸€æ¬¡ä»¥ä¿è¯å†…å­˜å®‰å…¨ï¼Œè¿™ä¸ªå‡½æ•°åœ¨ rust ä¸­æ˜¯ **drop** å‡½æ•°ã€‚

``` rust
{
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{}", s); // This will print `hello, world!`
}
{
    let s = String::from("hello"); // s is valid from this point forward
    // do stuff with s
}                                  // this scope is now over, and s is no
                                    // longer valid
```

### æ•°æ®åœ¨å˜é‡é—´çš„ç§»åŠ¨å’Œæ‹·è´

ç›¸åŒçš„æ•°æ®å¯ä»¥åœ¨ä¸åŒçš„å˜é‡é—´è¿›è¡Œäº¤äº’ï¼Œå¯¹äºåŸºæœ¬çš„æ•°æ®ç±»å‹

``` rust
let x = 1;
let y = x;
```

x å’Œ y çš„å€¼å°†åŒæ—¶ä¸º 1ï¼Œå› ä¸º 1 æ˜¯ä¸€ä¸ªå›ºå®šé•¿åº¦çš„ç¼–è¯‘æœŸå·²çŸ¥çš„åˆ†é…åœ¨æ ˆä¸Šçš„ç®€å•æ•°æ®ã€‚è€Œå¯¹äºæ›´å¤æ‚çš„æ•°æ®ï¼Œå…¶è¡Œä¸ºå¯èƒ½å®Œå…¨ä¸åŒï¼š

``` rust
let s1 = String::from("hello");
let s2 = s1;
```

å¯¹äºå­—ç¬¦ä¸²è€Œè¨€ï¼Œå…¶ owner ç”±ä¸‰ä¸ªéƒ¨åˆ†ç»„æˆï¼šæŒ‡å‘å †æ•°æ®çš„æŒ‡é’ˆã€å®é™…æ•°æ®é•¿åº¦ä»¥åŠå †é¢„åˆ†é…å†…å­˜çš„é•¿åº¦ã€‚å½“å°† s1 èµ‹å€¼ç»™ s2ï¼Œä»…ä»…æ“ä½œä»¥ä¸Šä¸‰éƒ¨åˆ†æ•°æ®ï¼Œè€ŒçœŸå®æŒ‡å‘çš„æ•°æ®å´å¹¶ä¸ä¼šæ‹·è´ã€‚

ç„¶è€Œï¼Œåœ¨ rust ä¸­ï¼Œä»¥ä¸Šå¹¶ä¸æ˜¯ä¸€ä¸ªç®€å•çš„æµ…æ‹·è´ï¼Œè‹¥ç¬¦åˆæµ…æ‹·è´çš„è¡Œä¸ºï¼Œåˆ™ s1 å’Œ s2 ä¸¤ä¸ª owner å°†å…±äº«ä¸€ä»½ç›¸åŒçš„æ•°æ®ï¼Œæ‰€ä»¥å½“ s1 å’Œ s2 åŒæ—¶ç¦»å¼€æ‰€å±çš„ä½œç”¨åŸŸåï¼Œå¿…ç„¶å¯¼è‡´äº†å †ç›¸åŒæ•°æ®çš„é‡å¤é‡Šæ”¾ã€‚

æ•…ï¼Œåœ¨ s1 èµ‹å€¼ç»™ s2 åï¼Œs1 å°†å¤±æ•ˆï¼Œè¿™ä¹Ÿå¯¼è‡´å½“ s1 ç¦»å¼€å…¶ä½œç”¨åŸŸæ—¶ï¼Œå°†ä¸ä¼šå‘ç”Ÿä»»ä½•äº‹æƒ…ï¼Œè¿™æ˜¯ä¸€ä¸ª**ç§»åŠ¨**æ“ä½œï¼Œè€Œéæ‹·è´ï¼Œå­—ç¬¦ä¸² "hello" æ‰€å ç”¨çš„å†…å­˜é‡Šæ”¾çš„ä»»åŠ¡å°†äº¤ç”± s2 å®Œæˆã€‚å› æ­¤ï¼Œä»¥ä¸‹çš„è¡Œä¸ºå°†å¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸º s1 å·²ç»æ˜¯ä¸€ä¸ªéæ³•çš„å˜é‡ï¼š

``` rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1);
```

> rust æ°¸è¿œä¸ä¼šä¸»åŠ¨è¿›è¡Œæ•°æ®çš„æ·±æ‹·è´ã€‚

è‹¥éœ€è¦æ·±æ‹·è´çš„æ“ä½œï¼Œè¯·è°ƒç”¨ clone å‡½æ•°ï¼Œæ­¤æ—¶ï¼Œs1 å’Œ s2 æŒæœ‰çš„æ˜¯ä¸åŒå†…å­˜ä¸Šçš„åŒå€¼æ•°æ®ï¼Œclone æ‹·è´äº†å †æ•°æ®ã€‚

``` rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

ç„¶è€Œï¼Œä»¥ä¸Šçš„æ¦‚å¿µå¯¹äºåªå­˜åœ¨äºæ ˆä¸Šçš„æ•°æ®è€Œè¨€ï¼Œçœ‹èµ·æ¥æ˜¯æ— æ•ˆçš„ã€‚æ­£å¦‚ï¼š

``` rust
let x = 1;
let y = x;
```

æ­¤æ—¶ x å’Œ y åŒæ—¶æ‹¥æœ‰æ•°å€¼ 5ï¼Œæ²¡æœ‰è°ƒç”¨ cloneï¼Œä¹Ÿæ²¡æœ‰ç§»åŠ¨è¡Œä¸ºçš„å‘ç”Ÿï¼ˆx å¹¶æœªå¤±æ•ˆï¼‰ã€‚

åŸå› åœ¨äºï¼Œæ•°æ® 1 æ˜¯ä¸€ä¸ªå°ºå¯¸å¤§å°å·²çŸ¥åˆ†é…åœ¨æ ˆä¸Šçš„æ•´å‹æ•°æ®ï¼Œæµ…æ‹·è´æˆ–æ·±æ‹·è´å¯¹äºè¿™ç§æ•°æ®æ¥è¯´å¹¶æ²¡æœ‰ä»€ä¹ˆä¸åŒã€‚å› æ­¤ï¼Œå¯¹äºè¿™ç§ç®€å•æ•°æ®ç±»å‹ï¼Œåˆ™å¿½ç•¥ç§»åŠ¨å’Œå…‹éš†è¯­ä¹‰ã€‚

rust ä¸ºè¿™ç§ç±»å‹æä¾›äº† Copy traitï¼Œé€šè¿‡è°ƒç”¨ Copy å¯ä»¥å°†è¯¥æ•°æ®å­˜æ”¾åœ¨æ ˆä¸Šã€‚è‹¥ä¸€ä¸ªæ•°æ®ç±»å‹å®ç°äº† Copyï¼Œåˆ™å…¶ä¸èƒ½å®ç° Dropï¼Œåä¹‹ä¹Ÿç›¸åŒã€‚Copy ä¿è¯äº†èµ‹å€¼ç»™æ–°çš„æ•°æ®åæ—§çš„æ•°æ®ä»ç„¶å¯ç”¨ã€‚

åŒ…æ‹¬æ•´å‹ã€å¸ƒå°”ã€æµ®ç‚¹ç±»å‹ã€å­—ç¬¦ç±»å‹ã€å…¨éƒ¨å…ƒç´ å‡å«æœ‰ Copy çš„ å…ƒç»„ç±»å‹ç­‰ï¼Œéƒ½å®ç°äº† Copyã€‚

### æ‰€æœ‰æƒå’Œå‡½æ•°

rust å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼Œåœ¨ä½¿ç”¨ä¸Šå’Œå…¶ä»–è¯­è¨€æœ‰å¾ˆå¤§åŒºåˆ«ã€‚ä¼ å€¼ç»™å‡½æ•°ç±»ä¼¼äºç»™å˜é‡èµ‹å€¼ã€‚å› æ­¤ï¼Œå¯¹äºå®ç°äº† Copy çš„æ•°æ®ç±»å‹çš„æ•°æ®ï¼Œä¼ ç»™å‡½æ•°å¹¶ç¦»å¼€å‡½æ•°ä½œç”¨åŸŸåï¼Œè¯¥æ•°æ®ä»ç„¶å¯ç”¨ï¼Œå¯¹äºå®ç°äº† Drop çš„æ•°æ®ï¼Œå½“ä¼ é€’ç»™å‡½æ•°åï¼Œç›¸å½“äºæ‰§è¡Œäº†ç§»åŠ¨è¯­ä¹‰ï¼ŒåŸå§‹å˜é‡æ— æ•ˆï¼Œæ­¤æ•°æ®çš„ç”Ÿå‘½å‘¨æœŸå°†äº¤ç”±å‡½æ•°ç®¡ç†ã€‚

è¿™ä¸ªä¾‹å­å¯ä»¥æ¸…æ™°åœ°è¯´æ˜è¿™ä¸ªé—®é¢˜ï¼š

``` rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

åŒæ ·ï¼Œå¯¹äºå‡½æ•°çš„è¿”å›å€¼ï¼Œåœ¨è¿”å›åå°†ç§»åŠ¨ç»™è°ƒç”¨è€…ï¼Œå¹¶ç”±å…¶è°ƒç”¨è€…ç®¡ç†ç”Ÿå‘½å‘¨æœŸã€‚

``` rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```

å¦‚æœè°ƒç”¨å‡½æ•°åä»ç„¶å¸Œæœ›ä½¿ç”¨åŸæœ‰çš„å‚æ•°å‘¢ï¼Ÿå¯ä»¥è€ƒè™‘å°†å‚æ•°è¿”å›ååœ¨ç»§ç»­ä½¿ç”¨ï¼š

``` rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```

ä¸è¿‡ï¼Œrust æä¾›çš„å¼•ç”¨å°†æ›´å¥½åœ°è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

## å¼•ç”¨å’Œå€Ÿç”¨ ï¼ˆReference and Borrowingï¼‰

å¦‚ä¸Šä¸€å°èŠ‚æ‰€è¿°ï¼Œåœ¨å‡½æ•°è°ƒç”¨å‘ç”Ÿåä»ç„¶éœ€è¦ä½¿ç”¨åŸæœ‰å‚æ•°å˜é‡æ˜¯å¸¸è§çš„éœ€æ±‚ï¼Œé™¤äº†å‡½æ•°å†æ¬¡è¿”å›è¯¥å‚æ•°ä½œä¸ºè§£å†³æ–¹æ¡ˆå¤–ï¼Œè¿˜å¯ä»¥ä½¿ç”¨å¼•ç”¨ï¼Œä½¿ç”¨å¼•ç”¨å°†èƒ½å¤Ÿå…³è”ä¸€äº›æ•°æ®å¹¶æ— éœ€æ¥ç®¡å…¶ç”Ÿå‘½å‘¨æœŸï¼š

``` rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

> ä¸å¼•ç”¨ç›¸åçš„æ“ä½œæ˜¯ï¼šè§£å¼•ç”¨ \*ï¼Œæ­¤å¤„ä¸åšä»‹ç»ã€‚

æˆ‘ä»¬ä¼ é€’ "&s1" ä½œä¸ºå‡½æ•°çš„å‚æ•°ï¼Œä¸”ï¼Œå‡½æ•°å‚æ•° "s: &String" è¡¨æ˜å…¶æ¥å—ä¸€ä¸ª String ç±»å‹çš„å¼•ç”¨ã€‚å‡½æ•°å‚æ•°åœ¨å‡½æ•°å†…æœ‰æ•ˆï¼Œå½“ç¦»å¼€å‡½æ•°ä½œç”¨åŸŸåï¼Œs ä¸ä¼šé‡Šæ”¾ s1 æ‰€æŒæœ‰çš„æ•°æ®ã€‚

æˆ‘ä»¬æŠŠä½¿ç”¨å¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°æˆä¸ºå€Ÿç”¨ã€‚æ³¨æ„ï¼Œæ­£å¦‚å˜é‡çš„ä¸å¯å˜ï¼Œå¼•ç”¨åœ¨é»˜è®¤æƒ…å†µä¸‹åŒæ ·ä¸å¯æ”¹å˜å…¶å¼•ç”¨çš„æ•°æ®ï¼Œå¦‚ä¸‹çš„ä¾‹å­è¯•å›¾ä¿®æ”¹å¼•ç”¨çš„æ•°æ®ï¼Œå°†æ— æ³•é€šè¿‡ç¼–è¯‘ï¼š

``` rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

é‚£ä¹ˆå¦‚ä½•ä¿®æ”¹è¢«å¼•ç”¨çš„æ•°æ®ï¼Ÿéœ€å¼•ç”¨ä¸€ä¸ª mut å˜é‡ï¼Œå¹¶åœ¨å‡½æ•°ç­¾åä¸­ä½¿ç”¨ "&mut"ï¼š

``` rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

ä½†æ˜¯ï¼Œrust è¦æ±‚ä¸€ä¸ªå˜é‡åœ¨ä¸€ä¸ªä½œç”¨åŸŸä¸­åªèƒ½æ¥å—ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œå¦åˆ™å°†ç¼–è¯‘å¤±è´¥ï¼š

``` rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
```

è¿™ç§é™åˆ¶é˜²æ­¢äº†æ•°æ®ç«äº‰ï¼Œå°¤å…¶åœ¨ä»¥ä¸‹å‡ ç§åœºæ™¯ä¸­ï¼š

- å¤šä¸ªæŒ‡é’ˆåŒæ—¶æŒ‡å‘ç›¸åŒçš„æ•°æ®ï¼›
- è‡³å°‘ä¸€ä¸ªæŒ‡é’ˆæ­£åœ¨å†™æ•°æ®ï¼›
- æ²¡æœ‰æ•°æ®åŒæ­¥æœºåˆ¶ï¼›

rust é€šè¿‡è¿™ç§æœºåˆ¶é¿å…äº†æ•°æ®çš„ç«äº‰ï¼Œå®ƒç”šè‡³åœ¨æœ‰æ½œåœ¨æ•°æ®ç«äº‰å‘ç”Ÿçš„å¯èƒ½ä¸‹ç¦æ­¢ç¼–è¯‘è¿™ä»½ä»£ç ã€‚

å½“ç„¶ï¼Œå¯ä»¥åœ¨ä¸åŒä½œç”¨åŸŸä¸­ä½¿ç”¨å¤šä¸ªå¯å˜å¼•ç”¨ï¼š

``` rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 goes out of scope here, so we can make a new reference with no problems.

let r2 = &mut s;
```

æ­¤å¤–ï¼Œå½“å­˜åœ¨ä¸€ä¸ªå¯å˜å¼•ç”¨æ—¶ï¼Œæ— æ³•å­˜åœ¨ä¸å¯å˜å¼•ç”¨ï¼Œå› ä¸ºéœ€è¦åœ¨ä¸å¯å˜å¼•ç”¨å­˜ç»­æœŸé—´ä¿è¯å˜é‡çš„ä¸å¯å˜æ€§ï¼Œä¸è¿‡å¤šä¸ªä¸å¯å˜å¼•ç”¨å¯ä»¥åŒæ—¶å­˜åœ¨ï¼š

``` rust
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
let r3 = &mut s; // BIG PROBLEM

println!("{}, {}, and {}", r1, r2, r3);
```

åªæœ‰åœ¨ä¸å¯å˜å¼•ç”¨æœ€åä¸€æ¬¡ä½¿ç”¨åï¼Œæ‰èƒ½å®šä¹‰æ–°çš„å¯å˜å¼•ç”¨ï¼Œå› ä¸ºæ­¤æ—¶æ— éœ€ä¿è¯æ•°æ®çš„ä¸å˜æ€§ï¼š

``` rust
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
println!("{} and {}", r1, r2);
// r1 and r2 are no longer used after this point

let r3 = &mut s; // no problem
println!("{}", r3);
```

è¿˜æœ‰ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œå¯èƒ½å­˜åœ¨ç©ºæ‚¬å¼•ç”¨ï¼Œåœ¨ä½¿ç”¨æŒ‡é’ˆçš„è¯­è¨€ç³»ç»Ÿä¸­ï¼Œè¿™æ˜¯ä¸€ä¸ªå¸¸è§çš„é—®é¢˜ï¼Œä¸è¿‡ rust çš„ç¼–è¯‘å™¨ä¿è¯äº†ç©ºæ‚¬å¼•ç”¨ä¸ä¼šå­˜åœ¨ï¼Œå½“å­˜åœ¨è¿™ç§æƒ…å†µå°†ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼š

``` rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```

å‡½æ•°è¯•å›¾è¿”å›ä¸€ä¸ªå·²ç»ç¦»å¼€å£°æ˜å‘¨æœŸçš„å˜é‡çš„å¼•ç”¨æ˜¯å±é™©çš„æ“ä½œï¼Œä¸è¿‡ rust å·²ç»åœ¨ç¼–è¯‘å™¨å¸®æˆ‘ä»¬é¿å…äº†è¿™äº›å¯èƒ½ã€‚å¦‚æœè¿”å›çš„æ˜¯å˜é‡ï¼Œåˆ™ä¼šé€šè¿‡ç§»åŠ¨å°†ç”Ÿå‘½å‘¨æœŸç§»äº¤ï¼Œä¸ä¼šå­˜åœ¨è¿™ç§é—®é¢˜ã€‚

> å¼•ç”¨
>
> ä»»ä½•æ—¶å€™ï¼Œåªèƒ½å­˜åœ¨ä¸€ä¸ªå¯å˜å¼•ç”¨æˆ–å¤šä¸ªä¸å¯å˜å¼•ç”¨ï¼Œä¸”å¼•ç”¨å­˜åœ¨æœŸé—´å¿…é¡»åˆæ³•ã€‚

## åˆ‡ç‰‡ç±»å‹ï¼ˆSlice Typeï¼‰
