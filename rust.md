---
title: Learning Rust
date: 2021-06-16 00:39:24
tags:
    - Rust
    - Programing language
    - Learn-note
categories: Language
toc: true
---

é˜…è¯»  [rust online book](https://doc.rust-lang.org/book/) æ—¶è®°å½•çš„ç¬”è®°ï¼Œè¾…ä»¥å¤‡å¿˜ã€‚

<!-- more -->

Rustå…·æœ‰å®‰å…¨é«˜æ•ˆç­‰è¯­è¨€ç‰¹æ€§ï¼Œæä¾›äº†3ä¸ªå·¥å…·ï¼š

- cargo: ä¾èµ–ç®¡ç†å’Œæ„å»ºå·¥å…·
- rustfmt: ä»£ç é£æ ¼
- Rust Language Server

# ä¸€ã€å¼€å§‹å­¦ä¹ rust

## hello, world

``` rust
// main.rs
fn main() {
    println!("hello, world!");
}
```

å¯¹äºè¿™ä¸ªèµ·ç‚¹ç¨‹åºï¼Œå’ŒCè¯­è¨€ç±»ä¼¼ï¼Œmain å‡½æ•°æ˜¯ rust ç¨‹åºçš„å…¥å£ï¼Œå‡½æ•°ä½“ä½¿ç”¨ '{}' åŒ…å›´ï¼Œå°†å·¦å¤§æ‹¬å·å’Œå‡½æ•°å£°æ˜æ”¾åœ¨ä¸€è¡Œæ˜¯ rust æ¨èçš„ç¼–ç¨‹ä¹ æƒ¯,æ­¤å¤–ï¼Œrust è¯­è¨€é£æ ¼ä½¿ç”¨ 4 ä¸ªç©ºæ ¼æ¥ç¼©è¿›ï¼Œè€Œé TABï¼Œä¸”ä½¿ç”¨åˆ†å·ä½œä¸ºæ¯ä¸ªè¯­å¥è¡¨è¾¾çš„ç»“æŸã€‚å¯ä»¥ä½¿ç”¨ rustfmt å·¥å…·æ ¼å¼åŒ–ä»£ç ä¸ºå®˜æ–¹æ¨èçš„æ ¼å¼

``` shell
> rustfmt main.rs
```

å’Œcè¯­è¨€æœ‰æ‰€åŒºåˆ«çš„æ˜¯ï¼Œç”¨äºè¾“å‡ºçš„è¯­å¥ "println!" éå‡½æ•°ï¼Œè€Œæ˜¯ Rust macroï¼Œå®ƒå’Œå‡½æ•°çš„ç›´è§‚ä¸Šçš„åŒºåˆ«åœ¨äºæ˜¯å¦æœ‰ "!"ï¼Œè‹¥ "func_name" åˆ™ä¸ºä¸€ä¸ªæ™®é€šçš„å‡½æ•°

å¯¹äºç®€å•çš„ rust ç¨‹åºï¼Œå¯ä»¥ä½¿ç”¨ rustc è¿›è¡Œç¼–è¯‘ï¼Œå¹¶å¾—åˆ°å¯è¿è¡Œçš„äºŒè¿›åˆ¶æ–‡ä»¶

``` shell
> rustc main.rs
```

ç„¶è€Œå¯¹äºå¤æ‚çš„å·¥ç¨‹ï¼Œä½¿ç”¨ cargo æ¥ç®¡ç†é¡¹ç›®åˆ™æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚

## ä½¿ç”¨ Cargo

Cargo æ˜¯ Rust è¯­è¨€ç³»ç»Ÿä¸­çš„ä¾èµ–ç®¡ç†å’Œæ„å»ºå·¥å…·ã€‚åˆ©ç”¨cargoåˆ›å»ºæ–°çš„é¡¹ç›®ï¼Œå¹¶åˆ›å»ºæ‰€éœ€çš„æ–‡ä»¶é¡¹ï¼ŒåŒæ—¶åœ¨é git ä»“åº“ä¸­å°†åŒæ—¶åˆå§‹åŒ– git å¹¶æ·»åŠ  gitignore æ–‡ä»¶ã€‚

``` shell
> cargo new hello_cargo
> tree hello_cargo
  |- Cargo.toml
  |- src
    |- main.rs

```

åœ¨ Cargo.toml æ–‡ä»¶ä¸­è®°å½•äº†é¡¹ç›®ç›¸å…³ä¿¡æ¯å’Œä¾èµ–é¡¹ç›®ï¼Œæ–‡ä»¶ä¸ºTOML (Tomâ€™s Obvious, Minimal Language) æ ¼å¼ã€‚Cargo è®¾è®¡å¸Œæœ›å°†æºç æ”¾åˆ° srcç›®å½•ä¸­ï¼Œé¡¶å±‚ç›®å½•æ”¾ç½® READMEã€LICENSE ç­‰ã€‚

æ„å»ºå’Œè¿è¡Œä½¿ç”¨ Cargo åˆ›å»ºçš„é¡¹ç›®å¾ˆç®€å•ï¼Œåœ¨ç¬¬ä¸€æ¬¡æ„å»ºå®Œæˆåï¼Œåœ¨é¡¶å±‚ç›®å½•å°†åˆ›å»ºä¸€ä¸ª Cargo.lock æ–‡ä»¶ç”¨ä»¥è®°å½•ä¾èµ–ï¼Œæ— éœ€æ‰‹å·¥ç®¡ç†ã€‚

``` shell
> cd hello_cargo
# write binary file into target/
> cargo build 
# exec the program
> cargo run
# or exec the binary file direcly
> ./target/debug/hello_cargo
```

æ­¤å¤– Cargo æä¾›äº†å¿«é€Ÿæ£€æµ‹ä»£ç ä½†ä¸ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶çš„å‘½ä»¤ï¼Œå…¶é€Ÿåº¦å¿«äº buildï¼Œæ‰€ä»¥ç»å¸¸ check ä¸€ä¸‹åˆšåˆšå†™çš„ä»£ç æ˜¯ä¸ªå¾ˆå¥½çš„ä¹ æƒ¯ã€‚ 

``` shell
> cargo check
```

å½“ç¨‹åºå‘ç‰ˆä½¿ç”¨æ—¶ï¼Œä½¿ç”¨å¸¦æœ‰ --release å‚æ•°çš„ build å‘½ä»¤ç”Ÿæˆ release ç‰ˆæœ¬ï¼Œç¼–è¯‘å™¨ä¼˜åŒ–å°†ä½¿ç¨‹åºå…·å¤‡æ›´é«˜æ•ˆçš„è¿è¡Œæ•ˆç‡ï¼Œä½†æ˜¯ç¼–è¯‘æ—¶é—´ä¼šæ›´é•¿ã€‚

``` shell
> cargo build --release
```

# äºŒã€çŒœæ•°ç¨‹åºå®è·µ

å®è·µæ°¸è¿œæ˜¯å­¦ä¹ æ–°ä¸œè¥¿æœ€å¿«çš„æ–¹æ³•ã€‚ä¸‹é¢ä½¿ç”¨ç†ŸçŸ¥çš„çŒœæ•°æ¸¸æˆå­¦ä¹ ä¸€äº›æ–°çš„è¯­è¨€è§„åˆ™ã€‚

é¦–å…ˆï¼Œä½¿ç”¨åœ¨ä¸Šä¸€ç«  hello world ç¨‹åºçš„åŸºç¡€ä¸Šï¼Œå¼•å…¥äº†ä¸€äº›æ–°çš„çŸ¥è¯†ç‚¹ï¼š

``` rust
// main.rs
use std::io;

fn main() {
    println!("Guess the number!");
    println!("Please input your guess.");

    let mut guess = String::new();
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
    println!("Your guessd is: {}", guess);
}
```

é»˜è®¤æƒ…å†µä¸‹ rust åªå¼•å…¥äº†å°‘é‡çš„ç±»å‹ï¼Œä¸ºäº†è·å–ç”¨æˆ·çš„è¾“å…¥è¾“å‡ºï¼Œéœ€è¦ä½¿ç”¨ use å¼•å…¥ std::io åˆ°ä½œç”¨åŸŸä¸­ï¼Œstd è¡¨ç¤º io æ˜¯æ ‡å‡†åº“çš„ä¸€éƒ¨åˆ†ã€‚

rust ä½¿ç”¨ let å…³é”®å­—åˆ›å»ºå˜é‡å’Œå¸¸é‡ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œrust æä¾›çš„å˜é‡æ˜¯ä¸å¯å˜çš„ï¼Œè‹¥éœ€è¦å¯å˜çš„å˜é‡éœ€è¦æ˜¾å¼ä½¿ç”¨ mut å…³é”®å­—æŒ‡å‡ºã€‚

``` rust
let foo = bar;     // immutable
let mut foo = bar; // mutable
```

let mut guess = String::new() è¯­å¥ä¸­ï¼Œguess å˜é‡ç»‘å®šåˆ° String::new() çš„è¿”å›ç»“æœï¼ŒString æ˜¯æ ‡å‡†åº“æä¾›çš„å¯å˜çš„ã€utf-8 æ ¼å¼çš„å­—ç¬¦ä¸²ç±»å‹ï¼Œ"::" è¡¨ç¤º new æ˜¯ String çš„ä¸€ä¸ªå…³è”å‡½æ•°ï¼Œå…¶æ— éœ€å®ä¾‹åŒ–å³å¯è°ƒç”¨ï¼Œç±»ä¼¼å…¶ä»–è¯­è¨€çš„é™æ€å‡½æ•°ã€‚new() æ–¹æ³•å°†åˆ›å»ºä¸€ä¸ªæ–°çš„ String ç©ºå®ä¾‹ã€‚

ä¸ºäº†å’Œç”¨æˆ·äº¤äº’ï¼Œä½¿ç”¨äº† std::ioï¼Œio::stdin() å°†è¿”å› std::io::Stdinï¼Œå³æ ‡å‡† I/O çš„ä¸€ä¸ªå¥æŸ„ï¼Œread_line å‡½æ•°å°†ä»ç»ˆç«¯è·å–ç”¨æˆ·è¾“å…¥ï¼Œå¹¶**è¿½åŠ **åˆ° guess å­—ç¬¦ä¸²å˜é‡åï¼Œå› æ­¤ï¼Œguess å¿…é¡»æ˜¯ä¸€ä¸ªå¯å˜å¯¹è±¡ã€‚"&" è¡¨ç¤ºä½¿ç”¨äº†å¯¹è±¡çš„å¼•ç”¨ï¼Œä½¿ç”¨å¼•ç”¨ä»¥é¿å…å¯¹å˜é‡çš„é‡å¤æ‹·è´ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå¼•ç”¨å’Œå˜é‡ç›¸åŒï¼Œå‡ä¸ºä¸å¯å˜ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ "&mut guess" è€Œé "&guess"ã€‚

'.expect("...")' å¯¹å‡½æ•°è¿”å›ç»“æœçš„æ½œåœ¨é£é™©è¿›è¡Œå¤„ç†ã€‚read_line å‡½æ•°è¯»å–ç”¨æˆ·è¾“å…¥ï¼Œå¹¶è¿”å›ä¸€ä¸ª io::Result ç±»å‹çš„æ•°æ®ã€‚Result ç±»å‹å¹¿æ³›å­˜åœ¨äº rust çš„å¤šä¸ªæ¨¡å—ä¸­ï¼Œå…¶å®è´¨æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œå…¶å€¼åŒ…æ‹¬ Errã€Okï¼Œè‹¥å¾—åˆ°çš„è¿”å›å€¼ä¸º Errï¼Œåˆ™å°†å¯¼è‡´ç¨‹åº crash å¹¶ä½¿ç”¨expectæä¾›çš„ä¿¡æ¯ï¼Œè‹¥å¾—åˆ° Okï¼Œåˆ™è¿”å›å…¶æºå¸¦çš„æ•°å€¼ã€‚è‹¥ä¸ºä½¿ç”¨ expect å‡½æ•°ï¼Œåœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ï¼Œrust å°†ç»™å‡ºè­¦å‘Šã€‚

rust ä½¿ç”¨ "{}" ä½œä¸ºç¨‹åºæ ¼å¼åŒ–è¾“å‡ºçš„å ä½ç¬¦ï¼š

``` rust
let x = 5;
let y = 6;
println!("x={}, y={}", x, y);
```

å…¶æ¬¡ï¼Œä¸ºäº†å®ŒæˆçŒœæ•°æ¸¸æˆï¼Œéœ€è¦å­¦ä¹ å¦‚ä½•è·å¾—éšæœºæ•°ã€‚rust çš„æ ‡å‡†åº“ä¸­å¹¶ä¸æä¾›éšæœºæ•°çš„æ”¯æŒï¼Œä¸è¿‡å…¶æ‹¥æœ‰ä¸°å¯Œçš„ crates ä½œä¸ºè¯­è¨€çš„æ‰©å±•æ”¯æŒï¼Œä¿®æ”¹ Cargo.toml å¼•å…¥ rand æ¨¡å—çš„ä¾èµ–

```
[dependencies]
rand = "0.8.3"
```

cargo åœ¨æ‰§è¡Œ build æ—¶å°†è‡ªåŠ¨æ„å»ºå¯¹åº”çš„ä¾èµ–å…³ç³»ï¼ŒåŒ…æ‹¬ rand æ¨¡å—æœ¬èº«çš„ä¾èµ–å†…å®¹ã€‚å…¶ç‰ˆæœ¬å·ç¬¦åˆ SemVer æ ‡å‡†ï¼Œè¡¨æ˜é¡¹ç›®ä¾èµ–çš„ rand æ¨¡å—éœ€è¦åœ¨ 0.8.3 åˆ° 0.9.0 ä¹‹é—´ï¼Œé«˜äºæˆ–ç­‰äº 0.9.0 åˆ™æ— æ³•ä¿è¯ api çš„ä¸€è‡´æ€§ã€‚cargo build å°†åªå¯¹ç¨‹åºä¿®æ”¹å†…å®¹è¿›è¡Œç¼–è¯‘ï¼Œå¼•å…¥çš„ crates åªä¼šç¼–è¯‘ä¸€æ¬¡ã€‚Cargo.lock æŒ‡æ˜äº†ä¾èµ–é¡¹ç›®çš„ç‰ˆæœ¬ï¼Œä»è€Œä¿è¯ä»»ä½•æ—¶é—´ã€ä»»ä½•äººéƒ½å¯ä»¥æˆåŠŸç¼–è¯‘è¿™ä»½é¡¹ç›®ä»£ç ã€‚åœ¨ crates æœ‰å¯å‡çº§çš„ç‰ˆæœ¬æ—¶ï¼Œè¯·åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹æ‰§è¡Œ cargo updateã€‚è‹¥éœ€è¦å¤§ç‰ˆæœ¬çš„æ›´æ–°ï¼Œè¯·ä¿®æ”¹ Cargo.toml æ–‡ä»¶ã€‚

ä¸‹é¢ä½¿ç”¨ rand ç”Ÿæˆ 1 åˆ° 100 çš„éšæœºæ•°ï¼š

``` rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
}
```

Rng trait ä¸­å®šä¹‰äº†å¾ˆå¤šå…³äºéšæœºæ•°ç”Ÿæˆæ–¹æ³•çš„æ¥å£ï¼Œä¸ºäº†ä½¿ç”¨è¿™äº›æ–¹æ³•ï¼Œé¦–å…ˆä½¿ç”¨ use å¼•å…¥ã€‚rand::thread_rng æä¾›äº†éšæœºæ•°ç”Ÿæˆå™¨ï¼šåœ¨å½“å‰çº¿ç¨‹ä¸­å¹¶ä½¿ç”¨ç³»ç»Ÿç§å­è¿è¡Œã€‚åˆ©ç”¨ gen_range ç”Ÿæˆ 1 åˆ° 100 ä¹‹é—´çš„éšæœºæ•°ï¼ŒèŒƒå›´å·¦é—­å³å¼€ï¼Œå½“ç„¶ï¼Œä¹Ÿå¯ä½¿ç”¨ "1..=100" ä½œä¸ºå·¦é—­å³é—­çš„å‚æ•°ã€‚

å½“ä½¿ç”¨ä¸€ä¸ªæ–°çš„ crate æ—¶ï¼Œå¯ä»¥åœ¨é¡¹ç›®ç›®å½•ä¸­ä½¿ç”¨å‘½ä»¤ cargo doc --open æŸ¥çœ‹å½“å‰é¡¹ç›®ä¸­æ‰€æœ‰æ¨¡å—çš„æ–‡æ¡£ã€‚

æ¥ä¸‹æ¥ï¼Œéœ€è¦å¯¹ç”¨æˆ·è¾“å…¥å’Œéšæœºæ•°å­—è¿›è¡Œæ¯”è¾ƒï¼š

``` rust
use std::cmp::Ordering;

fn main() {
    let guess = 2;
    let secret_number = 3;
    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => {
            println!("You win!")
            // more
        },
    }
}

```

ä¸ºäº†è¿›è¡Œç»“æœçš„æ¯”è¾ƒï¼Œéœ€è¦å¼•å…¥ Orderingï¼Œç±»ä¼¼äº Resultï¼Œå…¶äº¦ä¸ºæšä¸¾ç±»å‹ï¼Œä¸è¿‡å…¶å†…åŒ…å« Greaterã€Lessã€Equal ä¸‰ä¸ªå…ƒç´ ã€‚ä½¿ç”¨å˜é‡çš„å†…è”æ–¹æ³• cmp å¯¹ä¸¤ä¸ªæ•°å€¼ç»“æœè¿›è¡Œæ¯”è¾ƒï¼Œå…¶å°†è¿”å›ä¸€ä¸ª Ordering ç±»å‹çš„ç»“æœï¼Œä½¿ç”¨ match å¯¹è¯¥ç»“æœè¿›è¡Œåˆ†æ”¯æ¯”è¾ƒï¼Œä¾æ¬¡æ¯”è¾ƒ 3 ç§ Ordering çš„å¯èƒ½å€¼ï¼Œå½“åŒ¹é…æˆåŠŸåˆ™æ‰§è¡Œ => åçš„è¯­å¥ï¼Œå¯ä»¥ä½¿ç”¨ "{}" æ‰§è¡Œå¤šæ¡è¯­å¥ã€‚

ä¸è¿‡ cmp å‡½æ•°éœ€è¦æ¯”è¾ƒç›¸åŒçš„ç±»å‹ï¼Œå¦‚æ•´æ•°å’Œ string æ‰§è¡Œ cmpï¼Œå°†æ— æ³•é€šè¿‡ç¼–è¯‘ã€‚rust å†…ç½®äº†ä¸€äº›åŸºæœ¬çš„ç±»å‹ï¼Œæ¯”å¦‚æ•°å­—çš„ i32ï¼Œu32ï¼Œi64ï¼Œu64 ç­‰ï¼Œåˆ†åˆ«è¡¨ç¤ºæœ‰ç¬¦å·å’Œæ— ç¬¦å·çš„ 32 ä½å’Œ 64 ä½æ•´å½¢æ•°æ®ï¼Œåœ¨å®šä¹‰å˜é‡æ—¶å¯æ˜ç¡®æŒ‡å‡ºï¼š

``` rust
{
    let secret_number = 3;
    let mut guess = String::new();
    let guess: u32 = guess.trim().parse().expect("Please input number!");
    // get input from terminal here
    match guess.cmp(secret_number) {
        // arms here
    }
}
```

åœ¨ rust ä¸­ï¼Œå¯ä»¥é‡å¤å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œè¿™åœ¨å°†ä¸€ä¸ªæ•°æ®ç±»å‹è½¬æ¢ä¸ºå…¶ä»–æ•°æ®ç±»å‹çš„æƒ…å†µä¸‹å¾ˆæœ‰ç”¨ï¼Œæ— éœ€å®šä¹‰ä¸¤ä¸ªä¸åŒç±»å‹çš„ç›¸åŒå˜é‡ã€‚trim å‡½æ•°å°†å»é™¤å­—ç¬¦ä¸²å‰åçš„ç©ºç™½å­—ç¬¦ï¼Œparse å‡½æ•°åˆ™è§£æå­—ç¬¦ä¸²å¹¶è½¬æ¢ä¸ºæ•°å­—ï¼Œå®šä¹‰å˜é‡æ—¶é€šè¿‡ ": u32" æŒ‡æ˜ guess ä¸ºæ— ç¬¦å·32ä½æ•´å‹æ•°æ®ï¼Œå› æ­¤ï¼Œrust åœ¨æ‰§è¡Œ cmp æ—¶ï¼Œå³å¯éšå¼æ¨æ–­ secret_number ä¸ºä¸€ä¸ª u32 ç±»å‹æ•°æ®ã€‚

rust å¯ä»¥ä½¿ç”¨ loop è¿›è¡Œå¾ªç¯ï¼Œå¹¶ä½¿ç”¨ break å’Œ continue å®ç°å¾ªç¯çš„è·³è½¬ã€‚

``` rust
fn main() {
    loop {
        // loop body
        // break;
        // continue;
    }
}
```

æœ€åï¼Œå¯ä»¥ä¸ºæ ‡å‡† io æä¾›æ›´å¥å£®çš„é”™è¯¯å¤„ç†æ–¹å¼:

``` rust
fn main() {
    loop {
        // ...
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(\_) => continue,
        };
        // ...
    }
}
```

Ok(num) åŒ¹é…é™„å¸¦ä¸€ä¸ªå‚æ•°çš„ Ok æšä¸¾å€¼ï¼ŒErr(\_) åŒ¹é…é™„å¸¦ä»»æ„å‚æ•°çš„é”™è¯¯ç»“æœã€‚å®Œæ•´ç¨‹åºå¦‚ä¸‹ï¼š

``` rust
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        // let guess: u32 = guess.trim().parse()
        //                        .expect("Please input a number!");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("Your guessd is: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too Big!"),
            Ordering::Equal => { 
                println!("You win!");
                break;
            },
        }
    }
}
```

# ä¸‰ã€è¯­è¨€åŸºç¡€

åœ¨è¿™ä¸€éƒ¨åˆ†ï¼Œä¸»è¦å­¦ä¹  rust è¯­è¨€çš„åŸºç¡€çŸ¥è¯†ï¼Œå¦‚å˜é‡ã€æ•°æ®ç±»å‹ã€å‡½æ•°ã€æ³¨é‡Šä»¥åŠæ§åˆ¶æµã€‚

å­¦ä¹ ä¹‹å‰ï¼Œè¯·é¦–å…ˆ[äº†è§£ rust ä¿ç•™çš„å…³é”®å­—](https://doc.rust-lang.org/book/appendix-01-keywords.html)ï¼Œåœ¨åç»­ç¨‹åºçš„ç¼–å†™è¿‡ç¨‹ä¸­ä»¥é¿å…ä½¿ç”¨è¿™äº›å…³é”®å­—æ¥å®šä¹‰è‡ªå·±çš„åç§°ã€‚

## å˜é‡åŠå…¶å¯å˜æ€§

æ­£å¦‚ç¬¬äºŒç« æåˆ°çš„ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œrust å®šä¹‰çš„å˜é‡éƒ½æ˜¯ä¸å¯å˜çš„ï¼Œè¿™ä¸å…¶ä»–è¯­è¨€æœ‰æ‰€åŒºåˆ«ï¼Œä¹ŸåŒæ ·å› æ­¤ä½¿ rust æ›´å…·å®‰å…¨æ€§å’Œå¹¶å‘æ€§ã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥æ ¹æ®éœ€è¦ï¼Œä»¤å®šä¹‰çš„å˜é‡å¯å˜ã€‚

å¦‚ä¹‹å‰æ‰€æåˆ°çš„ï¼Œrust ä½¿ç”¨ let æ¥å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œå¦‚æœè¯¥å˜é‡æ˜¯ä¸å¯å˜çš„ï¼Œä¸€æ—¦è¿™ä¸ªå˜é‡ç»‘å®šåˆ°æŸä¸ªå€¼åï¼Œå…¶å€¼å°†ä¸èƒ½è¢«æ”¹å˜ï¼Œå½“å°è¯•ç¼–è¯‘å¦‚ä¸‹çš„ç¨‹åºæ—¶ï¼Œå°†ä¼šå¤±è´¥ï¼Œå¹¶ç»™å‡º " cannot assign twice to immutable variable" çš„è­¦å‘Šã€‚

``` rust
fn main() {
    let x = 5;
    println!("x is {}", x);
    x = 6;
    println!("x is {}", x);
}
```

rust ä¿è¯äº†å£°æ˜ä¸ºä¸å¯å˜çš„å˜é‡ä¸€æ—¦ç»‘å®šäº†æ•°å€¼åå°†æ°¸è¿œä¸å†æ”¹å˜ï¼Œå¯¹äºè¿™ç§å˜é‡ï¼Œæ— éœ€è€ƒè™‘å…¶åœ¨ä½•æ—¶ã€ä½•å¤„ä»¥åŠæ€æ ·å‘ç”Ÿæ”¹å˜ã€‚

å¦‚æœéœ€è¦å¯å˜çš„å˜é‡ï¼Œéœ€è¦ä½¿ç”¨ mut å…³é”®å­—æ˜¾å¼å£°æ˜ï¼Œåªéœ€å°† mut æ”¾åœ¨å˜é‡åå‰å³å¯ã€‚æ­¤æ—¶æˆ‘ä»¬ä¿®æ”¹ä¸Šè¿°ç¨‹åºå³å¯æ­£å¸¸ç¼–è¯‘å¹¶è¿è¡Œï¼Œå› ä¸ºæˆ‘ä»¬æ“çºµçš„æ˜¯ä¸€ä¸ªå¯å˜çš„å˜é‡ã€‚ä½¿ç”¨å˜é‡çš„å¯å˜æ€§æ˜¯å¯¹é”™è¯¯å’Œæ•ˆç‡ç­‰é—®é¢˜çš„æƒè¡¡å’ŒæŠ˜ä¸­ï¼Œä¸å¯å˜è¡Œæä¾›äº†æ›´é«˜çš„å®‰å…¨æ€§ï¼Œè€Œå¯å˜å˜é‡åˆ™å¯èƒ½é¿å…äº†æ–°å˜é‡çš„åå¤åˆ›å»ºå’Œæ‹·è´ç­‰ã€‚

``` rust
fn main() {
    // let x = 5;
    let mut x = 5;
    println!("x is {}", x);
    x = 6;
    println!("x is {}", x);
}
```

åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œæœ‰å¸¸é‡ï¼ˆconstantï¼‰çš„æ¦‚å¿µï¼Œç±»ä¼¼äº rust çš„ä¸å¯å˜å˜é‡ï¼Œä½†æ˜¯ rust çš„å¸¸é‡å’Œå˜é‡å­˜åœ¨ä¸€äº›åŒºåˆ«ï¼š

- ä¸å…è®¸å°† mut å’Œå¸¸é‡ä¸€èµ·ä½¿ç”¨ï¼Œå› ä¸ºå¸¸é‡æ˜¯æ°¸è¿œçš„æ’å€¼ï¼Œè€Œéé»˜è®¤ä¸ºæ’å€¼ï¼›
- å½“ä½¿ç”¨ const è€Œä¸æ˜¯ let æ¥å£°æ˜ä¸€ä¸ªå¸¸é‡æ—¶ï¼Œå¿…é¡»æŒ‡æ˜æ•°æ®ç±»å‹ï¼›
- const å¯ä»¥å£°æ˜åœ¨ä»»æ„ä½œç”¨åŸŸä¸­ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨ï¼Œè€Œ let æ— æ³•å£°æ˜åœ¨å…¨å±€ä½œç”¨åŸŸä¸­ï¼›
- å¸¸é‡çš„å€¼åªèƒ½æ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œä¸èƒ½æ˜¯ä»»æ„ä¸€ä¸ªè¿è¡Œæ—¶è·å–çš„å€¼ã€‚

ä¸‹é¢å£°æ˜äº†ä¸¤ä¸ªå¸¸é‡ï¼Œrust å»ºè®®ä½¿ç”¨å¤§å†™ä½œä¸ºå¸¸é‡çš„åç§°ï¼Œå¦åˆ™å°†åœ¨ç¼–è¯‘å™¨ç»™å‡ºè­¦å‘Šã€‚

``` rust
const MAX: u32 = 123;
fn main() {
    let x = 5;
    const MIN: u32 = 123;
    println!("x is {}, MAX is {}, MIN is {}", x, MAX, MIN);
}
```

é™¤å˜é‡ä¸å¯å˜çš„ç‰¹æ€§å¤–ï¼Œå˜é‡ä¸å…¶ä»–è¯­è¨€ä»æœ‰ä¸€ä¸ªæ˜æ˜¾çš„ç‰¹ç‚¹ï¼šrust æ”¯æŒå¯¹å·²å®šä¹‰çš„å˜é‡è¿›è¡Œè¦†ç›–ï¼ˆå¸¸é‡ä¸å…·æœ‰è¿™æ ·çš„ç‰¹æ€§ï¼Œrust å°†å…¶ç§°ä¸º Shadowingï¼‰ï¼Œå³åœ¨å·²å®šä¹‰çš„å˜é‡åï¼Œå¯ä»¥é‡æ–°å®šä¹‰ä¸€ä¸ªåŒåçš„å˜é‡æ¥è¦†ç›–ï¼Œå¦‚ä¸‹é¢ç»™å‡ºçš„ç¨‹åºï¼Œæœ€å x çš„å€¼ä¸º 7ã€‚

``` rust
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x + 1;
    println!("x is {}", x);
}
```

Shadowing å’Œ mut æ˜¯ä¸åŒçš„ï¼Œè‹¥æ²¡æœ‰ let å…³é”®å­—ï¼Œè¿™ç§ "x = x + 1" å¯¹å˜é‡çš„æ“ä½œæ˜¯ä¸å…è®¸çš„ï¼Œé€šè¿‡Shadowing å¯ä»¥å¯¹å·²æœ‰å˜é‡è¿›è¡Œä¸€äº›è½¬æ¢å¹¶å¾—åˆ°æ–°çš„ä¸å¯å˜å˜é‡ã€‚

é™¤äº†ä¸Šè¿°ç‰¹æ€§å¤–ï¼ŒShadowing ä¹Ÿå¯ä»¥å®ç°ä¸åŒç±»å‹çš„è½¬æ¢ï¼Œè¿™å’Œ mut æ˜¯ä¸åŒçš„ï¼š

``` rust
let spaces = "  ";        // String
let spaces = space.len(); // integer
```

å¦‚æœä½¿ç”¨ mut æ¥å®šä¹‰ spacesï¼Œåˆ™æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå³æˆ‘ä»¬ä¸èƒ½æ”¹å˜ mut å˜é‡åçš„ç±»å‹ã€‚

## åŸºæœ¬æ•°æ®ç±»å‹

rust æ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œåœ¨ç¼–è¯‘æœŸå¿…é¡»æ˜ç¡®å„ä¸ªå˜é‡çš„æ•°æ®ç±»å‹ã€‚æ•°æ®ç±»å‹å¯ä»¥åœ¨ä»£ç ä¸­æ˜ç¡®æŒ‡å®šï¼Œé™¤æ­¤å¤–ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä¸Šä¸‹æ–‡æ¨æ–­ã€‚å¦‚çŒœæ•°æ¸¸æˆä¸­ï¼Œå®šä¹‰ guess å¿…é¡»æŒ‡å®šå…¶ç±»å‹ä¸º "u32"ï¼Œå¦åˆ™ï¼Œparse å‡½æ•°é€šè¿‡ç¼–è¯‘ã€‚

``` rust
let guess: u32 = "42".parse().expect("Not a number!");
```

ä¸‹é¢ä»‹ç» rust æ•°æ®ç±»å‹çš„ä¸¤ä¸ªå­é›†ï¼šæ ‡é‡ç±»å‹å’Œå¤åˆç±»å‹ã€‚

### æ ‡é‡ç±»å‹

rust ä¸­çš„æ ‡é‡ç±»å‹ï¼Œå³åœ¨å…¶ä»–è¯­è¨€ä¸­å¸¸è§çš„å¦‚æ•´å‹ã€æµ®ç‚¹ç±»å‹ã€å¸ƒå°”ç±»å‹å’Œå­—ç¬¦ç±»å‹ã€‚

#### æ•´å‹

åœ¨ rust è¡¨ç¤ºæ•´å½¢çš„æ–¹æ³•ä¸º "u/iä½é•¿åº¦"ï¼Œu è¡¨ç¤ºæ— ç¬¦å·æ•°ï¼Œiè¡¨ç¤ºæœ‰ç¬¦å·æ•´æ•°ï¼ŒåŒ…æ‹¬ï¼š

| é•¿åº¦ | æœ‰ç¬¦å· | æ— ç¬¦å· |
| :-----: | :----: | :----: |
| 8-bits | i8 | u8 |
| 16-bits | i16 | u16 |
| 32-bits | i32 | u32 |
| 64-bits | i64 | u64 |
| 128-bits | i128 | u128 |
| arch | isize | usize |

å¯ä»¥ä½¿ç”¨ "i/usize" ä½¿ç”¨æ“ä½œç³»ç»Ÿæ”¯æŒçš„æ•´å½¢é•¿åº¦ï¼Œåœ¨å¯¹é›†åˆè¿›è¡Œç´¢å¼•æ—¶å¸¸å¸¸ä½¿ç”¨åˆ°è¿™ç§ç±»å‹ã€‚æ­¤å¤–ï¼Œrust æ”¯æŒå¤šç§è¿›åˆ¶çš„å­—é¢å€¼è¡¨ç¤ºï¼š

| å­—é¢å€¼ç±»å‹ | è¡¨ç¤º |
| :-----: | :----: |
| 10è¿›åˆ¶ | 123_456_789 |
| 16è¿›åˆ¶ | 0xABCD |
| 8è¿›åˆ¶ | 0o77 |
| 2è¿›åˆ¶ | 0b1111_0000 |
| å­—ç¬¦(u8) | b'A'


#### æµ®ç‚¹ç±»å‹

rust ä½¿ç”¨ f32 å’Œ f64 åˆ†åˆ«è¡¨ç¤º 32 ä½æµ®ç‚¹æ•°å’Œ 64 ä½æµ®ç‚¹æ•°ï¼Œrust é»˜è®¤ä½¿ç”¨ 64 ä½æµ®ç‚¹æ•°ã€‚

``` rust
fn main() {
    let a = 1.0;        // f64
    let x: f32 = 1.2;   // f32
    let y: f64 = 2.2;   // f64
}
```

#### æ•°å€¼æ“ä½œ

åŒæ ·ï¼Œrust ä¸ºæ•°å€¼ç±»å‹æä¾›äº†åŠ å‡ä¹˜é™¤çš„æ“ä½œç¬¦ï¼Œå…¶è®¡ç®—ç»“æœç»‘å®šåˆ°ä¸€ä¸ªå˜é‡ä¸Šï¼š

``` rust
fn main() {
    let sum = 1 + 2;
    let dif = 2 - 1;
    let mul = 1 * 2;
    let div = 2 / 1;
    let m   = 2 % 1;
}
```

#### å¸ƒå°”ç±»å‹

rust ä½¿ç”¨ trueã€false ä½œä¸ºå¸ƒå°”å€¼ bool çš„å­—é¢å€¼ï¼š

``` rust
fn main() {
    let t = true;
    let f: bool = false; // with explicit type annotation
}
```

#### å­—ç¬¦ç±»å‹

rust çš„ char ç±»å‹ä¸º 4 å­—èŠ‚çš„é•¿åº¦çš„ unicode æ”¯æŒçš„å¸¸é‡å€¼ï¼Œèƒ½å¤Ÿè¡¨ç¤ºåŒ…æ‹¬ä¸­æ–‡ã€æ—¥æ–‡ç­‰å¤šç§å­—ç¬¦ã€‚ä½¿ç”¨å•å¼•å·è¡¨ç¤ºï¼š

``` rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
```

### å¤åˆç±»å‹

rust çš„å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªæ•°å€¼é›†åˆåˆ°ä¸€ä¸ªæ•°æ®ç±»å‹ä¸­æ¥è¡¨ç¤ºï¼Œä¸»è¦æœ‰ä¸¤ç§ï¼šå…ƒç»„ï¼ˆtuplesï¼‰å’Œæ•°ç»„ï¼ˆarraysï¼‰ã€‚

#### å…ƒç»„

å…ƒç»„æ˜¯ä¸€ç§å°†å¤šç§ä¸åŒç±»å‹æ•°æ®é›†åˆåˆ°ä¸€èµ·çš„å¸¸ç”¨çš„æ–¹æ³•ï¼Œå…¶ä¸€æ—¦åˆ›å»ºï¼Œé•¿åº¦å›ºå®šä¸å¯ä¿®æ”¹ï¼Œå…ƒç»„ä½¿ç”¨åœ†æ‹¬å·è¡¨ç¤ºï¼š

``` rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

ä½¿ç”¨å…ƒç»„ï¼Œæœ‰æ–¹ä¾¿çš„æ–¹æ³•å¯¹å…¶ä¸­çš„æ¯ä¸ªå…ƒç´ è§£åŒ…ï¼š

``` rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

é™¤æ­¤ä¹‹å¤–ï¼Œå¯ä»¥é€šè¿‡å…ƒç»„ç´¢å¼•æ¥è®¿é—®å…¶ä¸­ä»»æ„å…ƒç´ ï¼Œä½¿ç”¨ "tuple.index" å®ç°ï¼Œå…¶ç´¢å¼•èŒƒå›´ä» 0 å¼€å§‹ï¼š

``` rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

#### æ•°ç»„

æ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ çš„æ•°æ®ç±»å‹å¿…é¡»ç›¸åŒï¼Œå…¶é•¿åº¦æ˜¯å›ºå®šçš„ï¼Œä½¿ç”¨æ–¹æ‹¬å·è¡¨ç¤ºï¼š

``` rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

å½“æ‰€éœ€æ•°æ®é›†åˆä¸ºç›¸åŒç±»å‹ä¸”å¸Œæœ›å°†æ•°æ®åˆ†é…åœ¨å †ä¸Šè€Œä¸æ˜¯æ ˆä¸Šæˆ–å§‹ç»ˆéœ€è¦å›ºå®šæ•°é‡çš„æ•°æ®æ—¶ï¼Œä½¿ç”¨æ•°æ®å¯èƒ½æ˜¯ä¸€ä¸ªé€‰æ‹©ï¼Œä¸è¿‡ï¼Œå…¶ä¸å¦‚ vector ï¼ˆæ ‡å‡†åº“æä¾›ï¼Œåç»­ä»‹ç»ï¼‰çµæ´»ï¼Œåè€…å¯åŠ¨æ€æ‰©å®¹ã€‚è‹¥æ— æ³•æ˜ç¡®ä½¿ç”¨æ•°ç»„æˆ– vectorï¼Œè¯·ä½¿ç”¨ vectorã€‚

å¦‚ï¼Œç¨‹åºéœ€è¦å›ºå®šçš„ä¸€äº›ä¿¡æ¯ï¼Œä½¿ç”¨ arrayï¼š

``` rust
fn main() {
    let months = ["January", "February", "March", "April", "May", "June", "July",
                "August", "September", "October", "November", "December"];
}
```

å£°æ˜æ•°ç»„æ—¶ï¼Œä¹Ÿå¯æŒ‡æ˜å…ƒç´ ç±»å‹å’Œé•¿åº¦ï¼š

``` rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

å¯ä»¥åˆ›å»ºä¸€ä¸ªæœ‰ç›¸åŒå…ƒç´ çš„æ•°ç»„ï¼š

``` rust
let a = [3; 5];
```

a çš„å€¼ä¸º [3, 3, 3, 3, 3]ã€‚

æ•°ç»„çš„å…ƒç´ å€¼å¯ä»¥ä½¿ç”¨ç´¢å¼•è®¿é—®ï¼š

``` rust
let a = [1, 2, 3, 4, 5];
let first = a[0];
let end   = a[4];
```

åœ¨ç¨‹åºä¸­ï¼Œå¦‚æœæ½œåœ¨ç´¢å¼•è¶Šç•Œï¼Œç¨‹åºæ˜¯å¯ä»¥ç¼–è¯‘æˆåŠŸçš„ï¼Œä½†å½“è¿è¡Œæ—¶é‡åˆ°è¶Šç•Œé—®é¢˜ï¼Œå°†å¯¼è‡´ç¨‹åºè¿è¡Œå¤±è´¥ã€‚åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œå½“é‡åˆ°è¶Šç•Œé—®é¢˜æ—¶ï¼Œç¨‹åºä¼šç»§ç»­è¿è¡Œï¼Œè€Œ rust å°†é˜»æ­¢è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œé€šè¿‡ç«‹å³é€€å‡ºæ¥é˜»æ­¢å¯¹éæ³•å†…å­˜çš„è®¿é—®ï¼Œè¿™é‡Œåˆ©ç”¨æ‰€å­¦çš„è¯­è¨€ç‰¹æ€§æä¾›äº†ä¾‹å­

``` rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("input index:");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Faile to read line");

    let index : usize = index.trim().parse().expect("Index not a number"); 

    let element = a[index];

    println!("value is {}, index is {}", element, index);
}
```

## å‡½æ•°

### å‡½æ•°å®šä¹‰å’Œä¼ å‚

rust ä½¿ç”¨ fn å…³é”®å­—æ¥å®šä¹‰å‡½æ•°ï¼Œå¦‚æ‰€è§çš„ main å‡½æ•°ï¼Œæˆ‘ä»¬åŒæ ·å¯ä»¥å®šä¹‰å…¶ä»–å‡½æ•°ï¼ŒåŒ…æ‹¬æ— å‚æ•°å‡½æ•°ã€æœ‰å‚æ•°å‡½æ•°ç­‰ï¼Œå‡½æ•°å‚æ•°å¿…é¡»æŒ‡æ˜æ•°æ®ç±»å‹ï¼Œå½“ç„¶å„ä¸ªå‚æ•°å¯ä»¥æœ‰å„è‡ªçš„ç±»å‹ã€‚

``` rust
fn main() {
    test();
    test_args(x: i32, y: i32);
}

fn test() {
    println!("This is test fn");
}

fn test_args(x: i32, y: i32) {
    println!("The arg is x:{}, y:{}", x, y);
}
```

### statements å’Œ expressions

å‡½æ•°ä½“ç”± statements å’Œ expressions ç»„æˆï¼Œexpressions æ˜¯ statement çš„ä¸€éƒ¨åˆ†ã€‚rust æ˜¯åŸºäºè¡¨è¾¾å¼çš„è¯­è¨€ ï¼ˆ expression-basedï¼‰ã€‚statement æ‰§è¡Œä¸€äº›åŠ¨ä½œä½†æ˜¯ä¸è¿”å›å€¼ï¼Œexpression æ€»æ˜¯èƒ½å¤Ÿæ¨æ–­å‡ºç»“æœã€‚å¦‚ let è¯­å¥ä¸ºä¸€ä¸ª statementï¼š

``` rust
fn main() {
    let x = 6;
}
```

å¦‚æœè¯•å›¾å°† let è¯­å¥ç»‘å®šåˆ°ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå°†æ— æ³•ç¼–è¯‘ï¼Œå› ä¸º let è¯­å¥ä¸èƒ½è¿”å›å€¼ï¼Œå› æ­¤ä¹Ÿä¸èƒ½ç»‘å®šæ–°çš„å˜é‡ã€‚å› æ­¤ï¼Œåœ¨ rust ä¸­ä¸ç±»ä¼¼äº C è¯­è¨€çš„ x=y=1 çš„è¡Œä¸ºä¸åŒã€‚

``` rust
fn main() {
    let y = (let x = 6); // comile error
}
```

ä»¥ä¸Šçš„å‡½æ•°å®šä¹‰ä¹Ÿæ˜¯ä¸€ä¸ª statementã€‚è€Œè®¡ç®—å¹¶å¯å¾—åˆ°ç»“æœçš„è¡¨è¾¾å¼ç»„æˆäº† rust ç¨‹åºçš„ç»å¤§éƒ¨åˆ†ï¼Œè¯¸å¦‚ 5 + 6ã€100ã€è°ƒç”¨å‡½æ•°ã€è°ƒç”¨å®ç­‰ä»¥åŠä½¿ç”¨ "{}" åŒ…è£¹çš„å¤šæ¡è¯­å¥ï¼Œéƒ½æ˜¯æˆ–èƒ½å¤Ÿæˆä¸ºè¡¨è¾¾å¼ï¼Œè¡¨è¾¾å¼çš„ç»“å°¾ä¸åŒ…å«åˆ†å·ï¼Œå¦åˆ™å…¶å°†è½¬æ¢ä¸º statementï¼Œå¹¶ä¸”å°†ä¸ä¼šè¿”å›å€¼ã€‚

``` rust
fn main() {
    let x = 1;
    let y = {
        let x = 10;
        x + 1
    }; // ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ³¨æ„ x + 1 åæ— åˆ†å·ç»“å°¾ï¼Œæ­¤ expression ç»“æœä¸º 11
    println!("x out is {}", x);
    println!("y is {}", y);
}
```

### å‡½æ•°è¿”å›å€¼

åœ¨ rust ä¸­ï¼Œ ä½¿ç”¨ "->" æ¥æŒ‡æ˜è¿”å›å€¼ç±»å‹ï¼Œæ•´ä¸ªå‡½æ•°ä½“å’Œ "{}" åŒ…è£¹çš„è¡¨è¾¾å¼æ˜¯åŒä¹‰çš„ã€‚å½“ç„¶ï¼Œå‡½æ•°å¯ä»¥ä½¿ç”¨ return å…³é”®å­—æå‰è¿”å›ç»“æœï¼Œå¤§å¤šæ•°å‡½æ•°éšå¼è¿”å›æœ€åä¸€ä¸ªè¡¨è¾¾å¼ã€‚

``` rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

å¦‚æœå‡½æ•°çš„æœ€åä¸€ä¸ªè¯­å¥åŠ ä¸Šäº†åˆ†å·ï¼Œä¸”æŒ‡æ˜å‡½æ•°éœ€è¦è¿”å›å€¼æˆ–éœ€è¦ä½¿ç”¨å®ƒçš„è¿”å›å€¼ï¼Œæ­¤æ—¶å°†æ— æ³•ç¼–è¯‘ï¼Œå› ä¸ºç°åœ¨ expression å› ä¸ºåˆ†å·å˜æˆäº† statementã€‚

## ç¨‹åºæ³¨é‡Š

æ”¯æŒ "//" çš„è¡Œæ³¨é‡Šå’Œæ–‡æ¡£æ³¨é‡Šï¼ˆåç»­ç« èŠ‚ä¸­ä»‹ç»ï¼‰ã€‚

## æ§åˆ¶æµ

### åˆ†æ”¯

ä½¿ç”¨ if else åˆ†æ”¯ï¼Œå½“ if åçš„æ¡ä»¶ä¸º trueï¼Œå°†æ‰§è¡Œå…¶å "{}" åŒ…è£¹çš„è¯­å¥ï¼Œæˆ–ç§° armsã€‚

``` rust
fn main() {
    let x = 7;
    if x > 5 {
        println!("x > 5");
    } else {
        println!("x <= 5");
    }
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œrust ä¸­ï¼Œif çš„æ¡ä»¶**å¿…é¡»æ˜¾å¼ä¸º bool ç±»å‹**ï¼Œå¦åˆ™ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼Œè¿™ä¸ C çš„éšå¼è½¬æ¢ä¸åŒã€‚

``` rust
fn main() {
    let y = 1;
    if y {
        println!("y is not 0");
    }
} // ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼Œä¸å­˜åœ¨åˆ° bool çš„éšå¼è½¬æ¢ã€‚
```

å½“å­˜åœ¨å¤šä¸ªæ¡ä»¶çŠ¶æ€æ—¶ï¼Œä½¿ç”¨ else if è¯­å¥å¤„ç†ï¼š

``` rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

å½“ä»£ç å­˜åœ¨è¿‡å¤šçš„ else if éœ€è¦è¿›è¡Œé‡æ„ï¼Œåç»­å°†ä»‹ç» match æ¥åº”å¯¹è¿™ç§çŠ¶å†µã€‚

### è¡¨è¾¾å¼ä¸­çš„åˆ†æ”¯

``` rust
fn main() {
    let z = if y { 199 } else { 299 };
    println!("z is {}", z);
}
```

éœ€è¦æ³¨æ„ï¼Œå„ä¸ª arms çš„å€¼çš„ç±»å‹å¿…é¡»ç›¸åŒï¼Œå¦åˆ™æ— æ³•ç¼–è¯‘ï¼Œrust å¿…é¡»åœ¨ç¼–è¯‘å™¨æ˜ç¡®å„ä¸ªå˜é‡çš„ç±»å‹ã€‚

### å¾ªç¯

ä½¿ç”¨ loop æ‰§è¡Œå¾ªç¯æ“ä½œï¼Œé…åˆ break å’Œ continue æ¥å®ç°å¾ªç¯å†…å¤æ‚çš„è·³è½¬ã€‚

``` rust
fun main() {
    loop {
        println!("again");
    }
}
```

ä¸ c è¯­è¨€ä¸åŒçš„ï¼Œrust çš„å¾ªç¯ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼ˆexpressionï¼‰ï¼Œå³å…¶å¯ä»¥è¿”å›å€¼ï¼š

``` rust
fn main() {
    let mut counter = 1;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("result is {}", result); // result = 20
}
```

### å¸¦æœ‰æ¡ä»¶çš„å¾ªç¯

å’Œå…¶ä»–è¯­è¨€ç±»ä¼¼ï¼Œrust æä¾›äº†å¸¦æœ‰æ¡ä»¶çš„ while å¾ªç¯ï¼Œå…¶è¡Œä¸ºå’Œå…¶ä»–è¯­è¨€ç±»ä¼¼ï¼š

``` rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }
    println!("LIFTOFF!!!");
}
```

### èŒƒå›´for

å½“éå†ä¸€ä¸ªé›†åˆæ—¶ï¼Œfor å¾ªç¯æ˜¯ä¸€ä¸ªæ–¹ä¾¿çš„é€‰æ‹©ï¼š

``` rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

å¦‚ä½¿ç”¨ for é€†åºæ‰“å°å¾— 3ã€2ã€1ï¼š

``` rust
for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
```


# å››ã€æ‰€æœ‰æƒï¼ˆownershipï¼‰

æ‰€æœ‰æƒæ˜¯ rust è¯­è¨€çš„é‡è¦æ¦‚å¿µï¼Œå…¶ä½¿ rust åœ¨æ²¡æœ‰åƒåœ¾å›æ”¶çš„æ¦‚å¿µä¸‹ä»ç„¶ä¿è¯äº†å†…å­˜å®‰å…¨ã€‚

## æ¦‚å¿µ

ç»§ç»­å­¦ä¹  rust ä¹‹å‰ï¼Œéœ€è¦äº†è§£æ‰€æœ‰æƒçš„æ¦‚å¿µã€‚å¯¹äºåŒ…å« GC çš„è¯­è¨€ï¼Œä½¿ç”¨è€…æ— éœ€æ‹…å¿§å†…å­˜çš„ä½¿ç”¨å’Œé‡Šæ”¾ï¼Œå¯¹äºç±»ä¼¼äº C çš„è¯­è¨€ï¼Œä½¿ç”¨è€…åˆ™å¿…é¡»æ˜ç¡®åœ¨åŠ¨æ€åˆ†é…çš„å†…å­˜æ— ç”¨æ—¶æ˜¾å¼é‡Šæ”¾ã€‚è€Œ rust åˆ™ä½¿ç”¨äº†å¦ä¸€ç§æ–¹æ³•ï¼šå…¶ä½¿ç”¨ä¸€ç³»åˆ—çš„è§„åˆ™åœ¨ç¼–è¯‘æœŸå°±æ˜ç¡®äº†å†…å­˜çš„æ‰€æœ‰æƒï¼Œæ‰€æœ‰æƒçš„ç‰¹æ€§ä¸ä¼šåœ¨è¿è¡Œæ—¶æ‹–æ…¢ç¨‹åºçš„æ•ˆç‡ã€‚

> **å †å’Œæ ˆ**
>
> å­˜å‚¨åœ¨æ ˆä¸Šçš„æ•°æ®å¿…é¡»åœ¨ç¼–è¯‘å™¨æ˜ç¡®äº†ä½¿ç”¨å†…å­˜çš„å°ºå¯¸ï¼Œå¯¹äºè¿è¡ŒæœŸæ‰èƒ½ç¡®å®šå†…å­˜çš„å˜é‡ï¼Œåˆ™åˆ†é…åœ¨å †ä¸Šã€‚å¯¹äºå †å’Œæ ˆä¸­çš„å˜é‡çš„ä½¿ç”¨ï¼Œå‰è€…çš„æ•ˆç‡æ˜æ˜¾ä½äºåè€…ï¼Œå› ä¸ºå‰è€…ä¼´éšäº†å†…å­˜åˆ†é…å™¨åˆ†é…å†…å­˜ç­‰ä¸€ç³»åˆ—çš„å¤æ‚æ“ä½œã€‚å¯¹äºè¿½è¸ªå˜é‡åˆ°åº•åˆ†é…åœ¨å †æˆ–æ ˆã€å‡å°‘å †ä¸­é‡å¤æ•°æ®ã€åŠæ—¶é‡Šæ”¾ä¸å†ä½¿ç”¨çš„å†…å­˜ç­‰ï¼Œéƒ½å±äºæ‰€æœ‰æƒé—®é¢˜ã€‚

### æ‰€æœ‰æƒè§„åˆ™

rust æ‰€æœ‰æƒçš„åŸºæœ¬è§„åˆ™å¦‚ä¸‹ï¼š

- æ¯ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ä½œä¸ºå®ƒçš„æ‹¥æœ‰è€…ï¼ˆownerï¼‰;
- æ¯ä¸€ä¸ªå€¼åªèƒ½æœ‰ä¸€ä¸ª ownerï¼›
- å½“ owner å˜é‡ç¦»å¼€å…¶ä½œç”¨åŸŸï¼ˆscopeï¼‰ï¼Œè¯¥å€¼å°†è¢«ä¸¢å¼ƒï¼ˆdropï¼‰ï¼›

### å˜é‡ä½œç”¨åŸŸ

æ­¤éƒ¨åˆ†å¹¶é rust ç‹¬æœ‰çš„æ¦‚å¿µï¼Œå…¶ä¸ C è¯­è¨€ä½œç”¨åŸŸçš„æ¦‚å¿µåŸºæœ¬ç›¸åŒï¼Œå˜é‡åœ¨åˆ›å»ºåç”Ÿæ•ˆï¼Œç¦»å¼€å…¶æ‰€åœ¨çš„ä½œç”¨åŸŸå¤±æ•ˆï¼š

``` rust
{                      // s is not valid here, itâ€™s not yet declared
    let s = "hello";   // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid
```

### String ç±»å‹

ä¸ºäº†è¿›ä¸€æ­¥è¯´æ˜ä½œç”¨åŸŸçš„æ¦‚å¿µï¼Œæ­¤å¤„å¼•å…¥äº†æ›´å¤æ‚çš„æ•°æ®ç±»å‹ã€‚å‰é¢æåˆ°çš„æ•´å‹ç­‰æ•°æ®ç±»å‹ï¼Œå‡åˆ†é…åœ¨æ ˆä¸­ï¼ŒString ç±»å‹åˆ™æ˜¯åˆ†é…åœ¨å †ä¸Šçš„ä¸€ä¸ªä¾‹å­ã€‚ä½¿ç”¨ String çš„ from å‡½æ•°åˆ›å»ºä¸€ä¸ªåˆå§‹åŒ–çš„å­—ç¬¦ä¸²ï¼Œå¹¶ä½¿ç”¨ push_str æ¥è¿½åŠ ã€‚å½“ä½¿ç”¨è°ƒç”¨ from å‡½æ•°æ—¶ï¼Œrust å°†åœ¨å †ä¸Šåˆ†é…å†…å­˜å¹¶å°†ä¸€ä¸ªå­—æ¯ä¸²å­—é¢å€¼èµ‹äºˆè¯¥å˜é‡ï¼Œå½“å­—ç¬¦ä¸²å˜é‡ç¦»å¼€å…¶ä½œç”¨åŸŸï¼Œä¸€ä¸ªç±»ä¼¼äº free çš„åŠ¨ä½œåˆ™å¿…é¡»ä¸”åªèƒ½è¢«è‡ªåŠ¨æ‰§è¡Œä¸€æ¬¡ä»¥ä¿è¯å†…å­˜å®‰å…¨ï¼Œè¿™ä¸ªå‡½æ•°åœ¨ rust ä¸­æ˜¯ **drop** å‡½æ•°ã€‚

``` rust
{
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{}", s); // This will print `hello, world!`
}
{
    let s = String::from("hello"); // s is valid from this point forward
    // do stuff with s
}                                  // this scope is now over, and s is no
                                    // longer valid
```

### æ•°æ®åœ¨å˜é‡é—´çš„ç§»åŠ¨å’Œæ‹·è´

ç›¸åŒçš„æ•°æ®å¯ä»¥åœ¨ä¸åŒçš„å˜é‡é—´è¿›è¡Œäº¤äº’ï¼Œå¯¹äºåŸºæœ¬çš„æ•°æ®ç±»å‹

``` rust
let x = 1;
let y = x;
```

x å’Œ y çš„å€¼å°†åŒæ—¶ä¸º 1ï¼Œå› ä¸º 1 æ˜¯ä¸€ä¸ªå›ºå®šé•¿åº¦çš„ç¼–è¯‘æœŸå·²çŸ¥çš„åˆ†é…åœ¨æ ˆä¸Šçš„ç®€å•æ•°æ®ã€‚è€Œå¯¹äºæ›´å¤æ‚çš„æ•°æ®ï¼Œå…¶è¡Œä¸ºå¯èƒ½å®Œå…¨ä¸åŒï¼š

``` rust
let s1 = String::from("hello");
let s2 = s1;
```

å¯¹äºå­—ç¬¦ä¸²è€Œè¨€ï¼Œå…¶ owner ç”±ä¸‰ä¸ªéƒ¨åˆ†ç»„æˆï¼šæŒ‡å‘å †æ•°æ®çš„æŒ‡é’ˆã€å®é™…æ•°æ®é•¿åº¦ä»¥åŠå †é¢„åˆ†é…å†…å­˜çš„é•¿åº¦ã€‚å½“å°† s1 èµ‹å€¼ç»™ s2ï¼Œä»…ä»…æ“ä½œä»¥ä¸Šä¸‰éƒ¨åˆ†æ•°æ®ï¼Œè€ŒçœŸå®æŒ‡å‘çš„æ•°æ®å´å¹¶ä¸ä¼šæ‹·è´ã€‚

ç„¶è€Œï¼Œåœ¨ rust ä¸­ï¼Œä»¥ä¸Šå¹¶ä¸æ˜¯ä¸€ä¸ªç®€å•çš„æµ…æ‹·è´ï¼Œè‹¥ç¬¦åˆæµ…æ‹·è´çš„è¡Œä¸ºï¼Œåˆ™ s1 å’Œ s2 ä¸¤ä¸ª owner å°†å…±äº«ä¸€ä»½ç›¸åŒçš„æ•°æ®ï¼Œæ‰€ä»¥å½“ s1 å’Œ s2 åŒæ—¶ç¦»å¼€æ‰€å±çš„ä½œç”¨åŸŸåï¼Œå¿…ç„¶å¯¼è‡´äº†å †ç›¸åŒæ•°æ®çš„é‡å¤é‡Šæ”¾ã€‚

æ•…ï¼Œåœ¨ s1 èµ‹å€¼ç»™ s2 åï¼Œs1 å°†å¤±æ•ˆï¼Œè¿™ä¹Ÿå¯¼è‡´å½“ s1 ç¦»å¼€å…¶ä½œç”¨åŸŸæ—¶ï¼Œå°†ä¸ä¼šå‘ç”Ÿä»»ä½•äº‹æƒ…ï¼Œè¿™æ˜¯ä¸€ä¸ª**ç§»åŠ¨**æ“ä½œï¼Œè€Œéæ‹·è´ï¼Œå­—ç¬¦ä¸² "hello" æ‰€å ç”¨çš„å†…å­˜é‡Šæ”¾çš„ä»»åŠ¡å°†äº¤ç”± s2 å®Œæˆã€‚å› æ­¤ï¼Œä»¥ä¸‹çš„è¡Œä¸ºå°†å¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸º s1 å·²ç»æ˜¯ä¸€ä¸ªéæ³•çš„å˜é‡ï¼š

``` rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1);
```

> rust æ°¸è¿œä¸ä¼šä¸»åŠ¨è¿›è¡Œæ•°æ®çš„æ·±æ‹·è´ã€‚

è‹¥éœ€è¦æ·±æ‹·è´çš„æ“ä½œï¼Œè¯·è°ƒç”¨ clone å‡½æ•°ï¼Œæ­¤æ—¶ï¼Œs1 å’Œ s2 æŒæœ‰çš„æ˜¯ä¸åŒå†…å­˜ä¸Šçš„åŒå€¼æ•°æ®ï¼Œclone æ‹·è´äº†å †æ•°æ®ã€‚

``` rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

ç„¶è€Œï¼Œä»¥ä¸Šçš„æ¦‚å¿µå¯¹äºåªå­˜åœ¨äºæ ˆä¸Šçš„æ•°æ®è€Œè¨€ï¼Œçœ‹èµ·æ¥æ˜¯æ— æ•ˆçš„ã€‚æ­£å¦‚ï¼š

``` rust
let x = 1;
let y = x;
```

æ­¤æ—¶ x å’Œ y åŒæ—¶æ‹¥æœ‰æ•°å€¼ 5ï¼Œæ²¡æœ‰è°ƒç”¨ cloneï¼Œä¹Ÿæ²¡æœ‰ç§»åŠ¨è¡Œä¸ºçš„å‘ç”Ÿï¼ˆx å¹¶æœªå¤±æ•ˆï¼‰ã€‚

åŸå› åœ¨äºï¼Œæ•°æ® 1 æ˜¯ä¸€ä¸ªå°ºå¯¸å¤§å°å·²çŸ¥åˆ†é…åœ¨æ ˆä¸Šçš„æ•´å‹æ•°æ®ï¼Œæµ…æ‹·è´æˆ–æ·±æ‹·è´å¯¹äºè¿™ç§æ•°æ®æ¥è¯´å¹¶æ²¡æœ‰ä»€ä¹ˆä¸åŒã€‚å› æ­¤ï¼Œå¯¹äºè¿™ç§ç®€å•æ•°æ®ç±»å‹ï¼Œåˆ™å¿½ç•¥ç§»åŠ¨å’Œå…‹éš†è¯­ä¹‰ã€‚

rust ä¸ºè¿™ç§ç±»å‹æä¾›äº† Copy traitï¼Œé€šè¿‡è°ƒç”¨ Copy å¯ä»¥å°†è¯¥æ•°æ®å­˜æ”¾åœ¨æ ˆä¸Šã€‚è‹¥ä¸€ä¸ªæ•°æ®ç±»å‹å®ç°äº† Copyï¼Œåˆ™å…¶ä¸èƒ½å®ç° Dropï¼Œåä¹‹ä¹Ÿç›¸åŒã€‚Copy ä¿è¯äº†èµ‹å€¼ç»™æ–°çš„æ•°æ®åæ—§çš„æ•°æ®ä»ç„¶å¯ç”¨ã€‚

åŒ…æ‹¬æ•´å‹ã€å¸ƒå°”ã€æµ®ç‚¹ç±»å‹ã€å­—ç¬¦ç±»å‹ã€å…¨éƒ¨å…ƒç´ å‡å«æœ‰ Copy çš„ å…ƒç»„ç±»å‹ç­‰ï¼Œéƒ½å®ç°äº† Copyã€‚

### æ‰€æœ‰æƒå’Œå‡½æ•°

rust å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼Œåœ¨ä½¿ç”¨ä¸Šå’Œå…¶ä»–è¯­è¨€æœ‰å¾ˆå¤§åŒºåˆ«ã€‚ä¼ å€¼ç»™å‡½æ•°ç±»ä¼¼äºç»™å˜é‡èµ‹å€¼ã€‚å› æ­¤ï¼Œå¯¹äºå®ç°äº† Copy çš„æ•°æ®ç±»å‹çš„æ•°æ®ï¼Œä¼ ç»™å‡½æ•°å¹¶ç¦»å¼€å‡½æ•°ä½œç”¨åŸŸåï¼Œè¯¥æ•°æ®ä»ç„¶å¯ç”¨ï¼Œå¯¹äºå®ç°äº† Drop çš„æ•°æ®ï¼Œå½“ä¼ é€’ç»™å‡½æ•°åï¼Œç›¸å½“äºæ‰§è¡Œäº†ç§»åŠ¨è¯­ä¹‰ï¼ŒåŸå§‹å˜é‡æ— æ•ˆï¼Œæ­¤æ•°æ®çš„ç”Ÿå‘½å‘¨æœŸå°†äº¤ç”±å‡½æ•°ç®¡ç†ã€‚

è¿™ä¸ªä¾‹å­å¯ä»¥æ¸…æ™°åœ°è¯´æ˜è¿™ä¸ªé—®é¢˜ï¼š

``` rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

åŒæ ·ï¼Œå¯¹äºå‡½æ•°çš„è¿”å›å€¼ï¼Œåœ¨è¿”å›åå°†ç§»åŠ¨ç»™è°ƒç”¨è€…ï¼Œå¹¶ç”±å…¶è°ƒç”¨è€…ç®¡ç†ç”Ÿå‘½å‘¨æœŸã€‚

``` rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```

å¦‚æœè°ƒç”¨å‡½æ•°åä»ç„¶å¸Œæœ›ä½¿ç”¨åŸæœ‰çš„å‚æ•°å‘¢ï¼Ÿå¯ä»¥è€ƒè™‘å°†å‚æ•°è¿”å›ååœ¨ç»§ç»­ä½¿ç”¨ï¼š

``` rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```

ä¸è¿‡ï¼Œrust æä¾›çš„å¼•ç”¨å°†æ›´å¥½åœ°è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

## å¼•ç”¨å’Œå€Ÿç”¨ ï¼ˆReference and Borrowingï¼‰

å¦‚ä¸Šä¸€å°èŠ‚æ‰€è¿°ï¼Œåœ¨å‡½æ•°è°ƒç”¨å‘ç”Ÿåä»ç„¶éœ€è¦ä½¿ç”¨åŸæœ‰å‚æ•°å˜é‡æ˜¯å¸¸è§çš„éœ€æ±‚ï¼Œé™¤äº†å‡½æ•°å†æ¬¡è¿”å›è¯¥å‚æ•°ä½œä¸ºè§£å†³æ–¹æ¡ˆå¤–ï¼Œè¿˜å¯ä»¥ä½¿ç”¨å¼•ç”¨ï¼Œä½¿ç”¨å¼•ç”¨å°†èƒ½å¤Ÿå…³è”ä¸€äº›æ•°æ®å¹¶æ— éœ€æ¥ç®¡å…¶ç”Ÿå‘½å‘¨æœŸï¼š

``` rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

> ä¸å¼•ç”¨ç›¸åçš„æ“ä½œæ˜¯ï¼šè§£å¼•ç”¨ \*ï¼Œæ­¤å¤„ä¸åšä»‹ç»ã€‚

æˆ‘ä»¬ä¼ é€’ "&s1" ä½œä¸ºå‡½æ•°çš„å‚æ•°ï¼Œä¸”ï¼Œå‡½æ•°å‚æ•° "s: &String" è¡¨æ˜å…¶æ¥å—ä¸€ä¸ª String ç±»å‹çš„å¼•ç”¨ã€‚å‡½æ•°å‚æ•°åœ¨å‡½æ•°å†…æœ‰æ•ˆï¼Œå½“ç¦»å¼€å‡½æ•°ä½œç”¨åŸŸåï¼Œs ä¸ä¼šé‡Šæ”¾ s1 æ‰€æŒæœ‰çš„æ•°æ®ã€‚

æˆ‘ä»¬æŠŠä½¿ç”¨å¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°æˆä¸ºå€Ÿç”¨ã€‚æ³¨æ„ï¼Œæ­£å¦‚å˜é‡çš„ä¸å¯å˜ï¼Œå¼•ç”¨åœ¨é»˜è®¤æƒ…å†µä¸‹åŒæ ·ä¸å¯æ”¹å˜å…¶å¼•ç”¨çš„æ•°æ®ï¼Œå¦‚ä¸‹çš„ä¾‹å­è¯•å›¾ä¿®æ”¹å¼•ç”¨çš„æ•°æ®ï¼Œå°†æ— æ³•é€šè¿‡ç¼–è¯‘ï¼š

``` rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

é‚£ä¹ˆå¦‚ä½•ä¿®æ”¹è¢«å¼•ç”¨çš„æ•°æ®ï¼Ÿéœ€å¼•ç”¨ä¸€ä¸ª mut å˜é‡ï¼Œå¹¶åœ¨å‡½æ•°ç­¾åä¸­ä½¿ç”¨ "&mut"ï¼š

``` rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

ä½†æ˜¯ï¼Œrust è¦æ±‚ä¸€ä¸ªå˜é‡åœ¨ä¸€ä¸ªä½œç”¨åŸŸä¸­åªèƒ½æ¥å—ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œå¦åˆ™å°†ç¼–è¯‘å¤±è´¥ï¼š

``` rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
```

è¿™ç§é™åˆ¶é˜²æ­¢äº†æ•°æ®ç«äº‰ï¼Œå°¤å…¶åœ¨ä»¥ä¸‹å‡ ç§åœºæ™¯ä¸­ï¼š

- å¤šä¸ªæŒ‡é’ˆåŒæ—¶æŒ‡å‘ç›¸åŒçš„æ•°æ®ï¼›
- è‡³å°‘ä¸€ä¸ªæŒ‡é’ˆæ­£åœ¨å†™æ•°æ®ï¼›
- æ²¡æœ‰æ•°æ®åŒæ­¥æœºåˆ¶ï¼›

rust é€šè¿‡è¿™ç§æœºåˆ¶é¿å…äº†æ•°æ®çš„ç«äº‰ï¼Œå®ƒç”šè‡³åœ¨æœ‰æ½œåœ¨æ•°æ®ç«äº‰å‘ç”Ÿçš„å¯èƒ½ä¸‹ç¦æ­¢ç¼–è¯‘è¿™ä»½ä»£ç ã€‚

å½“ç„¶ï¼Œå¯ä»¥åœ¨ä¸åŒä½œç”¨åŸŸä¸­ä½¿ç”¨å¤šä¸ªå¯å˜å¼•ç”¨ï¼š

``` rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 goes out of scope here, so we can make a new reference with no problems.

let r2 = &mut s;
```

æ­¤å¤–ï¼Œå½“å­˜åœ¨ä¸€ä¸ªå¯å˜å¼•ç”¨æ—¶ï¼Œæ— æ³•å­˜åœ¨ä¸å¯å˜å¼•ç”¨ï¼Œå› ä¸ºéœ€è¦åœ¨ä¸å¯å˜å¼•ç”¨å­˜ç»­æœŸé—´ä¿è¯å˜é‡çš„ä¸å¯å˜æ€§ï¼Œä¸è¿‡å¤šä¸ªä¸å¯å˜å¼•ç”¨å¯ä»¥åŒæ—¶å­˜åœ¨ï¼š

``` rust
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
let r3 = &mut s; // BIG PROBLEM

println!("{}, {}, and {}", r1, r2, r3);
```

åªæœ‰åœ¨ä¸å¯å˜å¼•ç”¨æœ€åä¸€æ¬¡ä½¿ç”¨åï¼Œæ‰èƒ½å®šä¹‰æ–°çš„å¯å˜å¼•ç”¨ï¼Œå› ä¸ºæ­¤æ—¶æ— éœ€ä¿è¯æ•°æ®çš„ä¸å˜æ€§ï¼š

``` rust
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
println!("{} and {}", r1, r2);
// r1 and r2 are no longer used after this point

let r3 = &mut s; // no problem
println!("{}", r3);
```

è¿˜æœ‰ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œå¯èƒ½å­˜åœ¨ç©ºæ‚¬å¼•ç”¨ï¼Œåœ¨ä½¿ç”¨æŒ‡é’ˆçš„è¯­è¨€ç³»ç»Ÿä¸­ï¼Œè¿™æ˜¯ä¸€ä¸ªå¸¸è§çš„é—®é¢˜ï¼Œä¸è¿‡ rust çš„ç¼–è¯‘å™¨ä¿è¯äº†ç©ºæ‚¬å¼•ç”¨ä¸ä¼šå­˜åœ¨ï¼Œå½“å­˜åœ¨è¿™ç§æƒ…å†µå°†ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼š

``` rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```

å‡½æ•°è¯•å›¾è¿”å›ä¸€ä¸ªå·²ç»ç¦»å¼€å£°æ˜å‘¨æœŸçš„å˜é‡çš„å¼•ç”¨æ˜¯å±é™©çš„æ“ä½œï¼Œä¸è¿‡ rust å·²ç»åœ¨ç¼–è¯‘å™¨å¸®æˆ‘ä»¬é¿å…äº†è¿™äº›å¯èƒ½ã€‚å¦‚æœè¿”å›çš„æ˜¯å˜é‡ï¼Œåˆ™ä¼šé€šè¿‡ç§»åŠ¨å°†ç”Ÿå‘½å‘¨æœŸç§»äº¤ï¼Œä¸ä¼šå­˜åœ¨è¿™ç§é—®é¢˜ã€‚

> å¼•ç”¨
>
> ä»»ä½•æ—¶å€™ï¼Œåªèƒ½å­˜åœ¨ä¸€ä¸ªå¯å˜å¼•ç”¨æˆ–å¤šä¸ªä¸å¯å˜å¼•ç”¨ï¼Œä¸”å¼•ç”¨å­˜åœ¨æœŸé—´å¿…é¡»åˆæ³•ã€‚

## åˆ‡ç‰‡ç±»å‹ï¼ˆThe Slice Typeï¼‰

### ä¸ä½¿ç”¨åˆ‡ç‰‡å¯èƒ½ä¼šäº§ç”Ÿçš„é—®é¢˜

é™¤äº†å¼•ç”¨æ²¡æœ‰æ‰€æœ‰æƒå¤–ï¼Œå¦ä¸€ä¸ªæ²¡æœ‰æ‰€æœ‰æƒçš„ç±»å‹æ˜¯åˆ‡ç‰‡ã€‚é€šè¿‡åˆ‡ç‰‡å¯ä»¥å€Ÿç”¨å­—ç¬¦ä¸²ã€æ•°ç»„ç­‰æ•°æ®çš„ä¸€éƒ¨åˆ†æˆ–å…¨éƒ¨ï¼Œä»è€Œé¿å…ä½¿ç”¨ç´¢å¼•ååŸæœ‰æ•°æ®å‘ç”Ÿæ”¹å˜å¯¼è‡´ç´¢å¼•æ— æ•ˆçš„é—®é¢˜ã€‚

è¿™é‡Œç»™å‡ºä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œåˆ›å»ºä¸€ä¸ªå‡½æ•°æ¥è·å¾—ä¸€ä¸ªå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå•è¯ã€‚æ³¨æ„å£°æ˜å‡½æ•°çš„æ ¼å¼ï¼ŒåŒ…æ‹¬å‚æ•°ã€è¿”å›å€¼ç±»å‹ä»¥åŠæœ€åä¸€ä¸ªè¯­å¥æ²¡æœ‰å†’å·ï¼ˆexpression è€Œé statementï¼‰ã€‚åœ¨ä¸å¼•å…¥åˆ‡ç‰‡æ—¶ï¼Œå‡½æ•°å¯ä»¥è¿”å›ç¬¬ä¸€ä¸ªç©ºç™½å­—ç¬¦çš„ä½ç½®ä½œä¸ºç¬¬ä¸€ä¸ªå•è¯ç»“å°¾çš„ç´¢å¼•ã€‚æ­¤å¤„ä½¿ç”¨ String çš„ as_bytes å°† String è½¬ä¸ºå­—ç¬¦æ•°ç»„ï¼Œä½¿ç”¨æ•°æ®çš„ iter å‡½æ•°è·å–è¿­ä»£å™¨ï¼Œä½¿ç”¨è¿­ä»£å™¨çš„ enumerate å‡½æ•°å°†è¿”å›æ•°ç»„çš„ç´¢å¼•å’Œå¯¹åº”ç´¢å¼•çš„å…ƒç´ æ‰€ç»„æˆçš„å…ƒç»„ï¼š

``` rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

ç„¶è€Œï¼Œå­˜åœ¨çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œå½“è°ƒç”¨å‡½æ•°åï¼ŒåŸå§‹å­—ç¬¦ä¸²å‘ç”Ÿäº†æ”¹å˜ï¼Œåˆ™è¿”å›çš„ç´¢å¼•å°†å¤±æ•ˆï¼Œè¿™å¯¼è‡´äº†æ½œåœ¨çš„ bugï¼š

``` rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```

å½“ç„¶ï¼Œå¯ä»¥æ¥åˆ¤æ–­ s çš„ sizeï¼Œä½†æ˜¯ï¼Œè¿™åˆå¦‚ä½•åˆ¤æ–­æ­¤æ—¶çš„ s æ˜¯å¦æ˜¯åŸæœ‰çš„ s å‘¢ï¼Ÿ


### å­—ç¬¦ä¸²åˆ‡ç‰‡

ä½¿ç”¨åˆ‡ç‰‡å¯ä»¥è§£å†³ä¸Šè¿°é—®é¢˜ï¼Œå­—ç¬¦ä¸²åˆ‡ç‰‡åœ¨ rust ä¸­ä½¿ç”¨ "&str" æ¥è¡¨ç¤ºï¼Œæ³¨æ„ï¼Œå…¶å’Œ String å¹¶ä¸æ˜¯ç›¸åŒçš„ç±»å‹ã€‚

``` rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

å­—ç¬¦ä¸²åˆ‡ç‰‡ä½¿ç”¨ &string_name\[begin..end\] æ¥è¡¨ç¤ºï¼Œå·¦é—­å³å¼€ã€‚è‹¥ begin ä¸ºå­—ç¬¦ä¸²å¼€å§‹ï¼Œå¯çœç•¥ï¼Œè‹¥ end ä¸ºå­—ç¬¦ä¸²ç»“å°¾ï¼Œå¯çœç•¥ï¼š

``` rust
let hello = &s[..5];  // hello çš„ç±»å‹ä¸º &strï¼Œé String
let world = &s[6..];
let hello_world = &s[..];
```

å­—ç¬¦ä¸²åˆ‡ç‰‡å®é™…ä¸Šæ˜¯å¯¹å­—ç¬¦ä¸²ä¸€éƒ¨åˆ†çš„å¼•ç”¨ï¼Œå…¶æ‰€å±æƒçš„è§„åˆ™ä¸å¼•ç”¨ç›¸åŒã€‚éœ€è¦æ³¨æ„ï¼Œåœ¨ä½¿ç”¨å­—ç¬¦ä¸²å¼•ç”¨æ—¶ï¼Œéœ€ä¿è¯å…¶å­—ç¬¦ä¸²ä¸ºutf-8æœ‰æ•ˆç¼–ç ã€‚

ä½¿ç”¨åˆ‡ç‰‡ï¼Œå¯ä»¥é‡å†™ä¸Šä¸€ä¸ªä¾‹å­ï¼Œéœ€è¦æ³¨æ„è¿”å›å€¼çš„ç±»å‹ï¼š

``` rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}
```

æ­¤æ—¶ï¼Œåœ¨è°ƒç”¨è¿™ä¸ªå‡½æ•°æ—¶åè€Œæœªä½¿ç”¨ word å‰ï¼Œè‹¥å°è¯•ä¿®æ”¹ s å°†æ— æ³•é€šè¿‡ç¼–è¯‘ï¼š

``` rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```

æ³¨æ„åœ¨å¼•å…¥å¼•ç”¨å’Œå€Ÿç”¨æ¦‚å¿µæ—¶ï¼Œæåˆ°è¿‡**å½“å­˜åœ¨ä¸å¯å˜å¼•ç”¨æ—¶ï¼Œä¸èƒ½åˆ›å»ºå¯å˜å¼•ç”¨**ï¼Œè°ƒç”¨å‡½æ•°åè¿”å›äº† s çš„ä¸€ä¸ªåˆ‡ç‰‡ï¼Œå³ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ï¼ˆåˆ‡ç‰‡é»˜è®¤ä¸ºä¸å¯å˜å¼•ç”¨ï¼‰ï¼Œå½“è¯•å›¾ä¿®æ”¹å­—ç¬¦ä¸² s æ—¶ï¼Œæ­¤æ—¶éœ€è¦ä½¿ç”¨æ•°æ®çš„ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œæ•…å¤±è´¥ã€‚å½“æœ€åä¸€æ¬¡ä½¿ç”¨ wordåï¼Œæˆ‘ä»¬æ‰èƒ½ä¿®æ”¹ sã€‚

ä½¿ç”¨åˆ‡ç‰‡ä¿æŒäº† word ç›¸å¯¹äº s çš„çŠ¶æ€ã€‚

### å­—ç¬¦ä¸²å­—é¢å€¼æ˜¯ä¸€ä¸ªåˆ‡ç‰‡

``` rust
let s = "Hello, world!"; // the type of s is &str
```

"Hello, world!" æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å­—é¢å€¼ï¼Œå…¶çœŸå®çš„æ•°æ®ç±»å‹ä¸ºå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œå³ &strï¼Œå› æ­¤å­—ç¬¦ä¸²å­—é¢å€¼æ˜¯ä¸å¯å˜çš„ã€‚

### å­—ç¬¦ä¸²åˆ‡ç‰‡ä½œä¸ºå‡½æ•°å‚æ•°

é™¤äº†ä¸Šè¿°ä½œä¸ºè¿”å›å€¼ï¼Œåˆ‡ç‰‡åŒæ ·å¯ä»¥ä½œä¸ºå‡½æ•°å‚æ•°ä¼ å…¥:
``` rust
fn first_word(s: &str) -> &str {
    // fn body
}
```

ä½¿ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡ä½œä¸ºå‚æ•°å…·æœ‰æ›´é«˜çš„é€‚ç”¨æ€§ï¼Œå¦‚æœå‚æ•°ç±»å‹æ˜¯ Stringï¼Œåˆ™æ— æ³•ä¼ å…¥åˆ‡ç‰‡ï¼Œç›¸åï¼Œå´èƒ½å¤Ÿç®€å•åœ°å°†å­—ç¬¦ä¸²ä½œä¸ºå‚æ•°ä¼ å…¥å‡½æ•°:


``` rust
fn main() {
    let my_string = String::from("hello world");

    // first_word works on slices of `String`s
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_word works on slices of string literals
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
```

### å…¶ä»–ç±»å‹çš„åˆ‡ç‰‡

ä¸æ­¢ Stringï¼Œè¿˜æœ‰ä¸€äº›æ•°æ®ç±»å‹ä¹Ÿæœ‰åˆ‡ç‰‡çš„æ¦‚å¿µï¼Œå¦‚å…ƒç´ ç±»å‹ä¸º u32 çš„æ•°ç»„ï¼Œå…¶åˆ‡ç‰‡ç±»å‹è¡¨ç¤ºä¸º &\[u32\]ï¼Œæ­¤å¤„ä»…ç®€å•äº†è§£å³å¯ï¼Œåç»­ä¼šæœ‰æ›´è¯¦ç»†çš„ä»‹ç»ã€‚


# äº”ã€æ•°æ®ç»“æ„

æ­¤ç« èŠ‚å­¦ä¹  rust ä¸­æ•°æ®ç»“æ„çš„å®šä¹‰å’Œä½¿ç”¨ã€‚

## å®šä¹‰å¹¶å®ä¾‹åŒ– struct

ä½¿ç”¨å…³é”®å­— struct å¯ä»¥å°†è®¸å¤šä¸åŒç±»å‹çš„æ•°æ®ç»„ç»‡åœ¨ä¸€èµ·ï¼Œä¾‹å¦‚ï¼Œå®šä¹‰ä¸€ä¸ªç®€å•çš„ç»“æ„ï¼š

``` rust
struct User {           // the name of the struct is User
    username: String,   // ver_name: ver_type,
    email: String,
    sign_in_count: u64,
    active: bool,
}
```

ä½¿ç”¨è¯¥ç»“æ„æ—¶ï¼Œä½¿ç”¨ struct_name { key: value} çš„å½¢å¼æ¥åˆ›å»ºå…¶å®ä¾‹ã€‚æ³¨æ„ï¼Œæ— éœ€åœ¨æ„å˜é‡çš„é¡ºåºï¼Œ

``` rust
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
```

å¯ä»¥ä½¿ç”¨ "." æ–¹æ³•æ¥è¯»å–æ•°æ®ï¼Œå¯¹äºå¯å˜çš„å®ä¾‹ï¼Œå¯ä»¥ä½¿ç”¨ "." æ–¹æ³•ä¿®æ”¹æ•°æ®ï¼Œæ­¤æ—¶æ•´ä¸ªç»“æ„çš„æ‰€æœ‰å˜é‡å‡å¯å˜ï¼Œrust ä¸å…è®¸ç»“æ„éƒ¨åˆ†å˜é‡å¯å˜ï¼š

``` rust
let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
```

å½“ç„¶å¯ä»¥ä½¿ç”¨å‡½æ•°æ¥å®ä¾‹åŒ–ä¸€ä¸ªç»“æ„ï¼š

``` rust
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
```

æ­¤å¤–ï¼Œrust æä¾›äº†æ›´æ–¹ä¾¿çš„ç‰¹æ€§æ¥é¿å…å‡½æ•°å‚æ•°åœ¨å®ä¾‹åŒ–ç»“æ„ä½“æ—¶éœ€è¦æ˜¾å¼æŒ‡æ˜çš„é—®é¢˜ï¼Œè‹¥å‡½æ•°å‚æ•°åå’Œç»“æ„ä½“çš„å…ƒç´ åç›¸åŒæ—¶ï¼Œå¯ä»¥çœç•¥å…¶valueï¼Œä¾‹å¦‚ï¼š

``` rust
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

æ­¤æ—¶ï¼Œåªéœ€è¦ä½¿ç”¨ email æ›¿ä»£ email: email å³å¯ã€‚ä¸ºäº†åˆ›å»ºä¸å·²æœ‰ struct ä»…å­˜åœ¨å°‘é‡åŒºåˆ«æ—¶ï¼Œä½¿ç”¨ update è¯­æ³•å¯ä»¥æ›´ç®€å•åœ°å®ç°è¿™ä¸ªéœ€æ±‚ã€‚ä¾‹å¦‚ï¼Œå·²æœ‰ user1ï¼Œæ­¤æ—¶éœ€è¦å»ºç«‹ä¸€ä¸ª user2ï¼Œå…¶åªæœ‰ email å’Œ username æ˜¯ä¸åŒçš„ï¼Œåˆ™å¯ä»¥åœ¨æŒ‡æ˜æ–°å˜é‡çš„ key: value åï¼Œä½¿ç”¨ ..user1 æŒ‡æ˜ user2 çš„å…¶ä»–åŸŸå…ƒç´ å‡å’Œ user1 ç›¸åŒï¼Œå¹¶ä» user1 çš„value è¿›è¡Œå®ä¾‹åŒ–å¯¹åº”å‚æ•°ã€‚æ³¨æ„ï¼Œæ­¤æ—¶ user2 æ˜¯ä¸€ä¸ªæ–°çš„å®ä¾‹ã€‚

``` rust
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
```

é™¤äº†ä¸Šè¿° struct çš„å½¢å¼å¤–ï¼Œrust è¿˜æ”¯æŒ tuple struct çš„å®šä¹‰ã€‚ä¸ä¸Šè¿°çš„æ™®é€š struct ç›¸æ¯”ï¼Œå…¶å†…å„ä¸ª fields æ²¡æœ‰å˜é‡å:

``` rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

å½“æˆ‘ä»¬éœ€è¦ä¸º tuple ç±»å‹æŒ‡æ˜ä¸€ä¸ªåå­—æ—¶ï¼Œå³å¯ä»¥è¿™æ ·å®šä¹‰ï¼Œå¦‚ä¸Šè¿°ä¾‹å­ï¼Œblack æ˜¯ Color çš„ä¸€ä¸ªå®ä¾‹ï¼Œorigin æ˜¯ä¸€ä¸ª Point çš„ä¸€ä¸ªå®ä¾‹ã€‚ä½†æ˜¯ï¼Œå°½ç®¡ Color å’Œ Point çš„å®šä¹‰å½¢å¼ç›¸åŒï¼Œä½†å®ƒä»¬ä¸æ˜¯ç›¸åŒçš„ç±»å‹ï¼Œæ•…éœ€è¦ Color å‚æ•°çš„å‡½æ•°ä¸æ¥å— Point ç±»å‹çš„å‚æ•°ã€‚tuple struct çš„å…¶ä»–è¡Œä¸ºç±»ä¼¼äºæ™®é€šçš„ tupleï¼Œå¦‚ ".index" æ¥ç´¢å¼•å…ƒç´ ã€è§£å…ƒç»„æ“ä½œç­‰ã€‚

struct ä¹Ÿæ”¯æŒç©ºçš„å®šä¹‰ï¼Œå³æ— ä»»ä½• fieldsã€‚è¿™å¯¹äºæŸäº›ç±»å‹ï¼šä¸åŒ…å«ä»»ä½•æ•°æ®ï¼Œä½†æ˜¯å…¶æ”¯æŒæŸäº›å‡½æ•°æ“ä½œï¼Œæ˜¯æœ‰ç”¨çš„ã€‚

struct çš„å…ƒç´ æ”¯æŒå¼•ç”¨ç±»å‹ï¼Œä½†æ˜¯ï¼Œæ­¤æ—¶éœ€è¦ä½¿ç”¨ rust ç”Ÿå‘½å‘¨æœŸçš„ç‰¹æ€§ï¼Œæ¥ä¿è¯ struct ä¸­çš„å…ƒç´ çš„ç”Ÿå‘½å‘¨æœŸé•¿äº struct ç»“æ„ï¼Œå¦‚ä¸‹çš„ä½¿ç”¨æ–¹æ³•æ˜¯æ— æ³•é€šè¿‡ç¼–è¯‘çš„ã€‚å…³äºå¦‚ä½•ä¿®å¤è¿™ä¸ªé—®é¢˜åç»­ä¼šæœ‰ä»‹ç»ã€‚

``` rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

## åœ¨ç¨‹åºä¸­ä½¿ç”¨ struct

æ­¤èŠ‚ä½¿ç”¨ struct å®ç°äº†ä¸€ä¸ªè®¡ç®—é•¿æ–¹å½¢é¢ç§¯çš„ç¨‹åºï¼Œé™¤äº†ä½¿ç”¨åˆ°äº†æ‰€å­¦åˆ°çš„ struct å¤–ï¼Œè¿˜ä½¿ç”¨äº†æ•°æ®å€Ÿç”¨ç­‰çŸ¥è¯†ç‚¹ï¼š

``` rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect = Rectangle {
        width: 50,
        height: 30,
    };

    // need define Display to use {} for Rectangle
    // println!("rect {} area is {}", rect, area(&rect));

    // need define Debug or
    println!("rect {:?} area is {}", rect, area(&rect));
     // add #[derive(Debug)] before struct Rectangle
    println!("rect {:#?} area is {}", rect, area(&rect));
}

fn area(rect: &Rectangle) -> u32 {
    rect.width * rect.height
}
```

ä¾‹å­ä¸­ï¼Œè¯•å›¾æ‰“å° Rectangle ç»“æ„ï¼Œæˆ‘ä»¬å°šæœªäº†è§£ struct çš„æ–¹æ³•ï¼Œè‹¥ä½¿ç”¨ "{}" æ¥åšå ä½ç¬¦ï¼Œåˆ™å¿…é¡»å®ç° Displayï¼Œæ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ "{:?}" å’Œ "{:#?}" æ¥ä½œä¸ºå ä½ç¬¦æ‰“å°è°ƒè¯•ä¿¡æ¯ï¼Œæ­¤æ—¶å¿…é¡»å®šä¹‰ Debug æˆ–åœ¨å®šä¹‰ç»“æ„ä½“å‰æ·»åŠ  "#[derive(Debug)]"ï¼ŒäºŒè€…çš„åŒºåˆ«åœ¨äºå‰è€…åªè¾“å‡ºç®€å•çš„å­—ç¬¦ä¸²ï¼Œåè€…æ›´æ¸…æ™°åœ°æ˜¾ç¤º struct ç»“æ„ã€‚

## struct çš„æ–¹æ³•

æ–¹æ³•ç±»ä¼¼äºå‡½æ•°ï¼Œä¸åŒçš„æ˜¯å…¶å£°æ˜äº struct å†…éƒ¨ï¼Œè€Œä¸”å…¶ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯ selfï¼ˆæƒ³åˆ°pythonäº†æ²¡~ï¼‰æ¥è¡¨ç¤º struct æœ¬èº«ï¼Œé€šè¿‡ä½¿ç”¨æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å°† ä¸Šè¿°ç¨‹åºé‡å†™å¦‚ä¸‹ï¼š

``` rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect = Rectangle {
        width: 50,
        height: 30,
    };

    println!("area is {}", rect.area());
}
```

ä½¿ç”¨ impl å…³é”®å­—ï¼Œå°† Rectangle æ‰€æ‹¥æœ‰çš„æ–¹æ³•å®šä¹‰åœ¨å…¶åçš„ "{}" ä¸­ï¼Œæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ "&self"ï¼Œå¹¶æœªæ˜ç¡®æŒ‡æ˜å…¶ç±»å‹ï¼Œå¦‚ "self: Rectangle"ï¼Œå› ä¸º rust å¯ä»¥è‡ªè¡Œæ¨æ–­ã€‚ä½¿ç”¨äº†å¼•ç”¨ï¼Œè¡¨ç¤ºäº†è¯¥æ–¹æ³•ä»…ä»…å€Ÿç”¨äº†å®ä¾‹çš„å˜é‡ï¼Œä¸æ‹¥æœ‰å…¶ç”Ÿå‘½å‘¨æœŸï¼Œè‹¥éœ€è¦æ›´æ”¹å®ä¾‹çš„å˜é‡å€¼ï¼Œå¿…é¡»ä½¿ç”¨ "&mut self" ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œç›´æ¥ä½¿ç”¨æ— å¼•ç”¨çš„ "self" ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¾ˆå°‘è§çš„ï¼Œä¸è¿‡åœ¨å°†æœ¬å®ä¾‹è½¬æ¢ä¸ºå…¶ä»–å®ä¾‹æ—¶å¯èƒ½ä¼šç”¨åˆ°ã€‚

ä¸è®ºæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ "self", "&self", "&mut self"ï¼Œåœ¨ä½¿ç”¨æ–¹æ³•æ—¶éƒ½æ— éœ€å…³å¿ƒæ˜¯å¦éœ€è¦å¯¹æ–¹æ³•æ‰€å±çš„å®ä¾‹çš„å¼•ç”¨é—®é¢˜ï¼Œrust è‡ªåŠ¨æä¾›äº†å¯¹åº”å†…å®¹ï¼Œå¦‚ä¾‹æ‰€ç¤ºï¼ŒäºŒè€…æ˜¯ç­‰ä»·çš„ï¼š

``` rust
p1.distance(&p2);
(&p1).distance(&p2);
```

å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ä¸ºæ–¹æ³•æä¾›æ›´å¤šçš„å‚æ•°ï¼š

``` rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width >= other.width && self.height >= other.height
    }
}
```

æ­¤å¤–ï¼Œåœ¨ impl çš„ä½œç”¨åŸŸä¸­ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å®šä¹‰å…³è”å‡½æ•°ï¼ˆAssociated Functionsï¼‰ï¼Œè¿™äº›å‡½æ•°ä¸éœ€è¦ self å‚æ•°ã€‚ä»–ä»¬å’Œ struct å…³è”åœ¨ä¸€èµ·ã€‚å…³è”å‡½æ•°é€šå¸¸ç”¨äºè¿”å›è¯¥ç»“æ„å¯¹åº”çš„æ–°å®ä¾‹ï¼Œä¾‹å¦‚ String çš„ from å‡½æ•°ï¼š

``` rust
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
```

å¦‚ä¸Šï¼Œå¯ä»¥åˆå§‹åŒ–ä¸€ä¸ªæ­£æ–¹å½¢ã€‚å¯¹äºå…³è”å‡½æ•°æ¥è®²ï¼Œä½¿ç”¨ "::" æ¥è°ƒç”¨ï¼š

``` rust
let sq = Rectangle::square(3);
```

æ¯ä¸ª struct å¯ä»¥æœ‰å¤šä¸ª impl åŒºåŸŸï¼Œå› æ­¤å¤šä¸ªæ–¹æ³•å¯ä»¥åˆ†åˆ«å®šä¹‰åœ¨ä¸åŒçš„ impl ä¸­ã€‚

# å…­ã€æšä¸¾å’Œæ¨¡å¼åŒ¹é…

## å®šä¹‰æšä¸¾

### å®šä¹‰å’Œä½¿ç”¨ç®€å•çš„æšä¸¾

æˆ‘ä»¬å¯ä»¥é€šè¿‡æšä¸¾æ¥å®šä¹‰äº‹ä»¶çš„æ‰€æœ‰ä¸åŒçš„å¯èƒ½æ€§ï¼Œå¦‚ ip åœ°å€çš„ç§ç±»ï¼ŒåŒ…æ‹¬ ipv4 å’Œ ipv6ï¼Œåˆ™ä¸ºäº†åç»­çš„åŒºåˆ†ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªæšä¸¾ï¼š

``` rust
enum IpAddrKind {
    V4,
    V6,
}
```

æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºè¯¥æšä¸¾çš„å®ä¾‹ï¼š

``` rust
let four = IpAddrKind::v4;
let six  = IpAddrKind::v6;
```

æšä¸¾ä¸­çš„æ‰€æœ‰çš„å…ƒç´ éƒ½å±äºè¯¥æšä¸¾å‘½åç©ºé—´ï¼Œæ­¤æ—¶ï¼Œfour å’Œ six åŒå±äº IpAddrKind ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å‡½æ•°ä¼ å…¥å‚æ•°æ¥ä½¿ç”¨æšä¸¾ï¼š

``` rust
fn use_enum(ip_kind: IpAddrKind) {
    // fn body
}
fn main() {
    let ipv4 = IpAddrKind::v4;
    use_enum(ipv4);
}
```

### å°†æšä¸¾ä¸æ•°æ®ç»‘å®š

ä¸ C è¯­è¨€ä¸­å¸¸è§çš„æšä¸¾ç±»å‹ä¸åŒçš„æ˜¯ï¼Œrust å¯ä»¥å°†æ•°æ®å’Œæšä¸¾ä¸­çš„å…ƒç´ ç»‘å®šåˆ°ä¸€èµ·ã€‚ä¾‹å¦‚ï¼Œå½“æˆ‘ä»¬éœ€è¦æ˜ç¡®æ¯ä¸ª ip åœ°å€æ˜¯ v4 ç‰ˆæœ¬è¿˜æ˜¯ v6ç‰ˆæœ¬çš„ï¼ŒæŒ‰ç…§å¾€å¸¸çš„æ€è·¯ï¼š

``` rust
enum IpAddrKind { V4, V6}
struct IpAddr {
    addr: String,
    kind: IpAddrKind,
}
```

å½“ç„¶ï¼Œä¸Šè¿°å†™æ³•æ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯æœ‰æ›´æ–¹ä¾¿çš„ç”¨æ³•ï¼š

``` rust
enum IpAddr {
    V4(String),
    V6(String),
}
```

æ­¤æ—¶ï¼Œæšä¸¾çš„æ¯ä¸ªå…·ä½“å€¼å¯ä»¥å’Œä¸€ä¸ª String ç±»å‹çš„æ•°æ®ç»‘å®šï¼š

``` rust
let home = IpAddr::V4(String::from("my.home.com"));
let remote = IpAddr::V6(String::from("::1"));
```

å› æ­¤ï¼Œå°±ä¸éœ€è¦é¢å¤–çš„ structã€‚ç„¶è€Œï¼Œè¿™å¹¶ä¸æ˜¯ enum ç‰¹æ€§çš„ç»ˆç‚¹ï¼šrust ä¸­ enum çš„ä¸åŒå…ƒç´ å¯ä»¥ç»‘å®šä¸åŒçš„æ•°æ®ç±»å‹ï¼š

``` rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}
```

ä¾‹å¦‚ï¼Œæ ‡å‡†åº“ IpAddr çš„å®šä¹‰æ–¹æ³•å¦‚ä¸‹ï¼š

``` rust
struct Ipv4Addr {
    // --snip--
}
struct Ipv6Addr {
    // --snip--
}
enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

> åœ¨ä¹‹å‰çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†è‡ªå·±çš„ IpAddrï¼Œå°½ç®¡æ ‡å‡†åº“ä¸­ä¹Ÿæä¾›äº†ç›¸åŒçš„åå­—ï¼Œä½†æ˜¯ç”±äºæˆ‘ä»¬å¹¶æ²¡æœ‰å°†å…¶å¼•å…¥ç¨‹åºçš„å‘½åç©ºé—´ï¼Œå› æ­¤å¹¶ä¸ä¼šå‘ç”Ÿå†²çªï¼


### æšä¸¾ä¸æ–¹æ³• 

ä½¿ç”¨æšä¸¾å¯ä»¥æœ‰æ›´å¤šçš„æƒ³è±¡ç©ºé—´ï¼Œå¦‚ï¼š

``` rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

å¹¶ä¸”å¯ä»¥ä¸ºå…¶å®šä¹‰é™„å¸¦çš„æ–¹æ³•ï¼š

``` rust
impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}
fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}
```

å¦‚æœæˆ‘ä»¬ä¸ºä½¿ç”¨ struct å®ç°ä¸Šè¿°æ“ä½œï¼Œéœ€è¦ä¸ºæ¯ç§åŠ¨ä½œå®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œé‚£ä¹ˆï¼Œå¤„ç†èµ·æ¥å°†ä¸é‚£ä¹ˆæ–¹ä¾¿ï¼æšä¸¾æ–¹æ³•çš„å®šä¹‰åŒ structã€‚

### Option enum

Option ç±»å‹æ˜¯æ ‡å‡†åº“ä¸­å®šä¹‰çš„å¦ä¸€ç§æšä¸¾ç±»å‹ï¼Œè¯¥æšä¸¾ä½¿ç”¨å¹¿æ³›ï¼Œå…¶å¯ä»¥ä»£è¡¨ somethingï¼Œä¹Ÿå¯ä»¥è¡¨ç¤º nothingã€‚å®é™…ä¸Šï¼Œ**rust ä¸åƒå…¶ä»–è¯­è¨€ä¸€æ ·ï¼Œå®ƒæ²¡æœ‰ null**ï¼Œnull è¡¨ç¤ºç”±äºæŸç§åŸå› å½“å‰æ²¡æœ‰å€¼æˆ–å½“å‰æ— æ•ˆçš„å€¼ï¼Œåœ¨æœ‰ null æ¦‚å¿µçš„è¯­è¨€ä¸­ï¼Œå…¶å€¼æˆ–æ˜¯ nullï¼Œæˆ–æ˜¯é nullï¼Œè€Œä¸”ï¼Œå½“æŠŠ null ä½œä¸ºé null æ¥ä½¿ç”¨çš„æ—¶å€™ï¼Œå¾€å¾€ä¼šé€ æˆä¸å¯ä¼°é‡çš„åæœã€‚

rust ä¸æä¾› nullï¼Œä½†æ˜¯å®ƒæœ‰ä¸€ä¸ªæšä¸¾å¯ä»¥ç”¨æ¥ç¼–ç å€¼çš„å­˜åœ¨ä¸å¦ï¼Œå³ "Option\<T\>"ï¼Œå…¶è¢«æ ‡å‡†åº“å®šä¹‰å¦‚ä¸‹ï¼š

``` rust
enum Option<T> {
    Some(T),
    None,
}
```

Option\<T\> å·²ç»åŒ…å«çš„ç¨‹åºçš„ä½œç”¨åŸŸä¸­ï¼Œæ— éœ€å¼•ç”¨ï¼ŒåŒæ—¶ï¼Œä½¿ç”¨ Some å’Œ None ä¹Ÿæ— éœ€ä½¿ç”¨ "Option::" å‰ç¼€ã€‚"\<T\>" æ˜¯ rust ä¸­çš„æ³›å‹å‚æ•°ï¼Œæ­¤æ—¶ï¼Œæˆ‘ä»¬åªéœ€äº†è§£ "\<T\>" è¡¨ç¤ºSome å¯ä»¥ä¿å­˜ä»»æ„ç±»å‹ï¼š

``` rust
let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;
```

å½“ä½¿ç”¨ None æ—¶ï¼Œéœ€è¦æ˜ç¡®æŒ‡æ˜è¯¥æ•°æ®çš„ç±»å‹ï¼Œä»¥ä¿è¯ rust åœ¨ç¼–è¯‘æœŸå¯ä»¥æ¨æ–­æ•°æ®ç±»å‹ã€‚æ­¤æ—¶éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒT å’Œ Option\<T\> å±äºä¸åŒçš„ç±»å‹ï¼Œä¸‹é¢çš„ä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘ï¼š

``` rust
let a: i8 = 5;
let b: Option<i8> = Some(10);

let c = a + b;
```

å½“æˆ‘ä»¬ä½¿ç”¨ T æ—¶ï¼Œç¼–è¯‘å™¨å¯ä»¥ä¿è¯æˆ‘ä»¬ä½¿ç”¨çš„æ°¸è¿œéƒ½æ˜¯åˆæ³•çš„æ•°æ®ï¼Œè€Œæ— éœ€æ£€æŸ¥å…¶æ˜¯å¦ä¸ºç©ºï¼Œåªæœ‰å½“æˆ‘ä»¬ä½¿ç”¨ Option\<T\> æ—¶ï¼Œæˆ‘ä»¬æ‰éœ€è¦æ‹…å¿ƒæ˜¯å¦æœ‰éæ³•æ•°æ®çš„ä½¿ç”¨é£é™©ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»å¯¹å…¶è¿›è¡Œæ£€æŸ¥åæ‰èƒ½ç»§ç»­ä½¿ç”¨ï¼Œå³æˆ‘ä»¬å¿…é¡»æ˜¾å¼å°† Option\<T\> è½¬æ¢ä¸º T ç±»å‹ï¼Œå¹¶ä¸”æ˜ç¡®æŒ‡æ˜å½“å…¶ä¸ºç©ºå€¼æ—¶çš„å¤„ç†æ–¹å¼ã€‚å…·ä½“å†…å®¹é˜…è¯»[æ–‡æ¡£](https://doc.rust-lang.org/std/option/enum.Option.html)ã€‚
## match

match æ˜¯ rust æä¾›çš„ä¸€ç§éå¸¸å¼ºå¤§çš„æ§åˆ¶æµæ“ä½œç¬¦ï¼Œå…¶å¯ä»¥åœ¨ä¸€ç³»åˆ—çš„æ¨¡å¼ï¼ˆPatternsï¼‰ä¸­è¿›è¡ŒåŒ¹é…ï¼Œå¹¶æ‰§è¡ŒåŒ¹é…æˆåŠŸåçš„æ¨¡å¼æ‰€å¯¹åº”çš„ä»£ç ã€‚æ­¤ä¸­çš„æ¨¡å¼å¯ä»¥æ˜¯å­—é¢å€¼ã€å˜é‡åã€é€šé…ç¬¦ï¼ˆwildcardsï¼‰ä»¥åŠå…¶ä»–å¤šç§ç±»å‹ã€‚ä½¿ç”¨ matchï¼Œå…·æœ‰å¼ºå¤§çš„åŒ¹é…èƒ½åŠ›ï¼Œæ­¤å¤–ï¼Œå…¶å¤„ç†äº†æ‰€æœ‰å¯èƒ½æ€§æ¥ä¿è¯ç¨‹åºçš„å®‰å…¨æ€§ã€‚

æ–‡æ¡£ç»™å‡ºäº†ä¸€ä¸ªç”ŸåŠ¨çš„ä¾‹å­ï¼šå¯ä»¥å°† match æ“ä½œç¬¦å·¥ä½œçš„è¿‡ç¨‹ç†è§£ä¸ºç¡¬å¸åˆ†æ‹£çš„æµç¨‹ï¼Œä¸åŒé¢å€¼çš„ç¡¬å¸å…¶ç›´å¾„ä¸åŒï¼Œè¿™äº›ç¡¬å¸ä¾æ¬¡é€šè¿‡å°ºå¯¸ä»å°åˆ°å¤§çš„å­”æ´ï¼Œå½“æŸä¸ªç¡¬å¸çš„ç›´å¾„å’Œå¯¹åº”å­”çš„ç›´å¾„åŒ¹é…çš„æ—¶å€™ï¼Œä¾¿ç­›é€‰å‡ºè¿™æšç¡¬å¸ï¼Œä½¿ç”¨ rust çš„ match æ¥å®ç°ä¸€ä¸ªç¡¬å¸é¢å€¼è‹±æ–‡åä¸å…¶æ•°å€¼åŒ¹é…çš„ç¨‹åºï¼š

``` rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => {
            println!("10");
            10
        },
        Coin::Quarter => 25,
    }
}
```

match å…³é”®å­—åè·Ÿéšå¾…åŒ¹é…çš„å¯¹è±¡ï¼Œå…¶ä¸ if ä¸åŒçš„æ˜¯ï¼Œif è¦æ±‚å…¶è¡¨è¾¾å¼çš„å€¼å¿…é¡»ä¸º bool ç±»å‹ï¼Œè€Œ match çš„åŒ¹é…å€¼å¯ä»¥ä¸ºä»»æ„ç±»å‹ã€‚ç”± "{}" åŒ…è£¹å¹¶ç”± "," åˆ†éš”çš„æ˜¯ match çš„å¤šä¸ª armsï¼Œæ¯ä¸ª arm åŒ…å«ç¬¦å· "=>" å·¦ä¾§çš„å¾…åŒ¹é…æ¨¡å¼å’Œå³ä¾§çš„åŒ¹é…åæ‰§è¡Œçš„ä»£ç ã€‚match æŒ‰ç…§ arms çš„é¡ºåºä¾æ¬¡åŒ¹é…æ£€æŸ¥ï¼Œå¦‚æœæ¨¡å¼ä¸èƒ½åŒ¹é…ï¼Œåˆ™ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªåŒ¹é…ï¼ŒåŒ¹é…åæ‰§è¡Œçš„ä»£ç æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå…¶è¡¨è¾¾å¼çš„å€¼æ˜¯ match æ“ä½œçš„è¿”å›å€¼ã€‚å¦‚æœåŒ¹é…åéœ€è¦æ‰§è¡Œå¤šè¡Œä»£ç ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ "{}" å°†å…¶åŒ…å›´ã€‚

å½“ä¸€ä¸ª arm è¢«åŒ¹é…å¹¶æ‰§è¡Œåï¼Œå°†ä¸ä¼šç»§ç»­åŒ¹é…ã€‚

match çš„å¦ä¸€ä¸ªæœ‰ç”¨çš„ç‰¹æ€§ï¼Œå…¶æ¯ä¸ª arm çš„ pattern å¯ä»¥ç”¨ä»¥åŒ¹é…ç»‘å®šå€¼çš„æšä¸¾ï¼Œå³ï¼šå½“ match åŒ¹é…ä¸€ä¸ªç»‘å®šäº†å€¼çš„æšä¸¾æ—¶ï¼Œå¯ä»¥åœ¨åŒ¹é…è¿‡ç¨‹å°†å…¶å€¼ç»‘å®šåˆ°æŒ‡å®šçš„å˜é‡ä¸­ã€‚å¦‚ä¸‹ä¾‹å­ï¼Œcoin è‹¥åŒ¹é…äº† Coin::Quarter(UsState) åˆ™ UsState çš„å€¼å°†ç»‘å®šåˆ° state ä¸Šï¼Œå¹¶åœ¨æ‰§è¡Œè¯¥ arm å¯¹åº”çš„ä»£ç æ—¶ä½¿ç”¨ã€‚

``` rust
enum Coin {
    YiJiao,
    WuJiao,
    YiYuan,
    BuCunZai(u32),
}
fn match_coin(coin: Coin) -> u32 {
    match coin {
        Coin::YiJiao => 1,
        Coin::WuJiao => 5,
        Coin::YiYuan => 10,
        Coin::BuCunZai(value) => value,
    }
}
fn main() {
    let coin1 = Coin::WuJiao;
    let coin2 = Coin::YiJiao;
    let coin3 = Coin::YiYuan;
    let coin4 = Coin::BuCunZai(100);
    println!(" value={}", match_coin(coin1));
    println!(" value={}", match_coin(coin2));
    println!(" value={}", match_coin(coin3));
    println!(" value={}", match_coin(coin4));
}
```

match è¿˜å¯ä»¥ç”¨ä»¥åŒ¹é… Option\<T\> ç±»å‹ï¼ˆä¹‹å‰å­¦ä¹ è¿‡ï¼Œå…¶ä¸ºæšä¸¾ç±»å‹ï¼Œå†…å« None å’Œ Some(val) ä¸¤ç§å˜ä½“ï¼Œç”¨ä»¥å¤„ç†ç©ºçš„æƒ…å†µï¼‰ï¼š

``` rust
fn plus_one(x: Option<u32>) -> Option<u32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let x = 1;
    let y = plus_one(Some(x));
    let z = plus_one(None);
    println!("{:?} {:?} {:?}", x, y, z);
}
```

> åœ¨ rust ä¸­ï¼Œä½¿ç”¨ match åŒ¹é…ä¸€ä¸ªæšä¸¾ï¼Œç»‘å®šæ•°æ®ï¼Œå¹¶ä½¿ç”¨è¯¥æ•°æ®è¿›è¡Œåç»­å¤„ç†æ˜¯å¸¸è§çš„æƒ…æ™¯ã€‚

ä½¿ç”¨ match æ—¶ï¼Œç‰¹åˆ«éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¿…é¡»å¤„ç†æšä¸¾æ‰€æœ‰å¯èƒ½çš„å€¼ï¼Œå¦åˆ™æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œè¿™ä¹Ÿå¢åŠ äº†ä»£ç çš„å®‰å…¨æ€§ã€‚é‚£ä¹ˆå¦‚æœæ— æ³•åˆ—å‡ºæ‰€æœ‰çš„æƒ…å†µè¯¥å¦‚ä½•ï¼Ÿä½¿ç”¨å ä½ç¬¦ï¼ˆPlaceholder) "_"ï¼Œå ä½ç¬¦å¯ä»¥åŒ¹é…ä»»ä½•å€¼ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœä¸ä½¿ç”¨å ä½ç¬¦ï¼ŒåŒæ ·æ— æ³•é€šè¿‡ç¼–è¯‘ï¼š

``` rust
    let some_u8_value = 0u8;
    match some_u8_value {
        1 => println!("one"),
        3 => println!("three"),
        5 => println!("five"),
        7 => println!("seven"),
        _ => (), // () è¡¨ç¤ºä¸€ä¸ª unit valueï¼Œä¸ä¼šå‘ç”Ÿä»»ä½•äº‹
    }
```

å¯¹äºå¤æ‚çš„åŒ¹é…åœºæ™¯æ¥è¯´ï¼Œmatch æ˜¯æœ‰ç”¨çš„ï¼Œä½†æ˜¯å¦‚æœåªæœ‰ç®€å•çš„åŒ¹é…é—®é¢˜å‘¢ï¼Œæˆ‘ä»¬åº”è¯¥ä½¿ç”¨ if letã€‚

## if let

ä½¿ç”¨ if let å¯ä»¥ä½¿ç”¨æ›´å°‘çš„ä»£ç å¤„ç†åªåŒ¹é…ä¸€ç§å€¼çš„æƒ…å½¢ï¼Œä¾‹å¦‚ï¼Œåªå¤„ç†ä¸€ä¸ªå€¼æ—¶ï¼š

``` rust
fn main() {
    let x = 1; 
    if let 1 = x {
        println!("x = 1");
    }
}
```

æ­¤æ—¶ï¼Œç­‰å·å³è¾¹æ˜¯å¾…åŒ¹é…çš„å€¼ï¼Œå·¦è¾¹æ˜¯ä¸ä¹‹åŒ¹é…çš„å€¼ã€‚å¦‚æœä½¿ç”¨ matchï¼Œè¿˜éœ€è¦ä½¿ç”¨å ä½ç¬¦å¤„ç†å…¶ä»–æƒ…å†µã€‚ä¸è¿‡ï¼Œä½¿ç”¨ if let å°±æ„å‘³ç€æ”¾å¼ƒäº† match çš„å®‰å…¨æ€§ã€‚å½“ç„¶ï¼Œif let ä¹Ÿå¯ä»¥å’Œ else ä¸€èµ·ä½¿ç”¨ï¼š

``` rust
fn main() {
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("State quarter from {:?}!", state);
    } else {
        count += 1;
    }
}
```

# ä¸ƒã€Packages, Crates, and Modules

ç›´è‡³æœ¬èŠ‚å¼€å§‹ä¹‹å‰ï¼Œå­¦ä¹ çš„ä»£ç éƒ½åœ¨ä¸€ä¸ªæ–‡ä»¶ã€ä¸€ä¸ª module ä¸­ã€‚éšç€é¡¹ç›®æ„ˆåŠ å¤æ‚ï¼Œæˆ‘ä»¬éœ€è¦æ›´é«˜æ•ˆçš„ä»£ç ç®¡ç†æ–¹æ³•ï¼Œå¦‚ï¼šæ‹†åˆ†ä»£ç åˆ°å¤šä¸ªæ–‡ä»¶ã€å¤šä¸ª modulesï¼›å¼•å…¥å°è£…æ¥é‡ç”¨ä»£ç å’ŒæŒ‡å®šç§æœ‰å±æ€§å’Œå…±æœ‰æ¥å£ç­‰ã€å¼•å…¥ scope æ¥å¤„ç†å‘½åé—®é¢˜ç­‰ã€‚

æœ¬ç« å°†ä¸»è¦å†…å®¹ï¼š

- Packagesï¼šCargo æä¾›çš„åŠŸèƒ½ï¼Œå¸®åŠ©æˆ‘ä»¬æ„å»ºã€æµ‹è¯•å’Œåˆ†äº«åˆ›å»ºçš„ cratesï¼›
- Cratesï¼šæ¨¡å—æ ‘ç”¨ä»¥ç”Ÿæˆåº“æˆ–å¯æ‰§è¡Œæ–‡ä»¶ï¼ˆ A tree of modules that produces a library or executableï¼‰ï¼›
- Modules and use: Let you control the organization, scope, and privacy of pathsï¼›
- Pathsï¼šå‘½åé¡¹ç›®çš„æ–¹å¼ï¼ˆå¦‚ structã€å‡½æ•°ã€moduleç­‰ï¼‰ã€‚

## Packages and Crates

åœ¨æ¨¡å—ç³»ç»Ÿä¸­ï¼Œé¦–å…ˆå­¦ä¹  packages å’Œ cratesã€‚

crate æ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶æˆ–è€…åº“ï¼ˆlibraryï¼‰ã€‚crate root æ˜¯ä¸€ä¸ªæºæ–‡ä»¶ï¼Œrustç¼–è¯‘å®ƒå¹¶æ„æˆ crate çš„ root moduleã€‚

package ç”±ä¸€ä¸ªæˆ–è€…å¤šä¸ª crate ç»„æˆå¹¶æä¾›ä¸€ç³»åˆ—åŠŸèƒ½ï¼Œå®ƒåŒ…å«ä¸€ä¸ª Cargo.toml æ–‡ä»¶ï¼Œä»¥è¡¨ç¤ºå¦‚ä½•æ„å»ºè¿™äº› cratesã€‚ä¸€ä¸ª package å¿…é¡»åŒ…å« 0 ä¸ªæˆ–è€… 1 ä¸ª library crateï¼Œä¸èƒ½å¤šäº 1 ä¸ªï¼›åŒæ—¶å¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„ binary cratesï¼Œä½†æ˜¯ä¸€ä¸ª package ä¸­åŒ…å«çš„ library crate å’Œ binary crate çš„æ•°é‡å¿…é¡»å¤§äºç­‰äº 1ã€‚

å½“æˆ‘ä»¬ä½¿ç”¨ cargo åˆ›å»ºä¸€ä¸ªæ–°çš„ rust é¡¹ç›®åï¼Œcargo é»˜è®¤ä¸ºæˆ‘ä»¬åˆ›å»ºäº†å¦‚ä¸‹æ–‡ä»¶ï¼š

``` shell
$ cargo new project && cd project
$ tree
.
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â””â”€â”€ main.rs

1 directory, 2 files
$ cat Cargo.toml
[package]
name = "show"
version = "0.1.0"
authors = ["vhdsih <vhdsih@hotmail.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
$
```

æ­¤æ—¶æˆ‘ä»¬æ–°å»ºçš„ project æ˜¯ä¸€ä¸ª packageï¼Œsrc/main.rc æ˜¯ binary crate çš„ rootï¼Œè‹¥å­˜åœ¨ src/lib.rs åˆ™å…¶ä¸º library crate çš„ rootï¼Œä¸€ä¸ª package æœ‰å¤šä¸ª binary cratesï¼Œå¹¶æŠŠå®ƒä»¬æ”¾åœ¨ src/bin ä¸‹ï¼Œæ­¤æ—¶æ¯ä¸ªæ–‡ä»¶æ˜¯ä¸€ä¸ªå•ç‹¬çš„ binary crateã€‚

src/main.rs å’Œ src/lib.rs å¯ä»¥ç†è§£ä¸ºæ­¤ package çš„ç¼–è¯‘å…¥å£ï¼Œå¹¶å°†å…¶ä¼ ç»™ rustcï¼ŒäºŒè€…å¯ä»¥åŒæ—¶å­˜åœ¨ï¼Œmain.rs å°†ç”ŸæˆäºŒè¿›åˆ¶å¯è¿è¡Œçš„æ–‡ä»¶ï¼Œlib.rs å°†å¯è¢«å…¶ä»–é¡¹ç›®å¼•ç”¨ã€‚ä»”ç»†è§‚å¯Ÿ Cargo.toml å¯ä»¥å‘ç°å¹¶æ²¡æœ‰æ˜ç¡®æŒ‡æ˜è¿™ä¸¤ä¸ªæ–‡ä»¶ä½œä¸º rootï¼Œè¿™æ˜¯å› ä¸ºè¿™æ˜¯é»˜è®¤æŒ‡å®šçš„ç‰¹æ€§ã€‚

æ¯ä¸ª crate å†…éƒ¨çš„æ–¹æ³•ç‹¬å±äºè¯¥ crate çš„å‘½åç©ºé—´ï¼Œå› æ­¤ï¼Œä¸åŒçš„ crate å¯ä»¥å®šä¹‰ç›¸åŒçš„åå­—è€Œä¸ä¼šå‘ç”Ÿå†²çªï¼Œä½†æ˜¯ç›¸åŒçš„ crate ä¸èƒ½å®šä¹‰ç›¸åŒçš„åå­—ï¼Œä¾‹å¦‚ rand è¿™ä¸ª crate ä¸­çš„ Rngï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è‡ªå·±çš„ main.rs ä¸­å®šä¹‰ struct Rngï¼ŒåŒæ—¶ä½¿ç”¨ rand::Rng æ¥ä½¿ç”¨ rand crate ä¸­çš„ Rngã€‚

## æ¨¡å—

æˆ‘ä»¬å¯ä»¥é€šè¿‡ modules åœ¨ä¸€ä¸ª crate ä¸­ç»„ç»‡ä»£ç ä»¥è¾¾åˆ°æ›´å¥½çš„å¯è¯»æ€§å’Œæ›´é«˜çš„æ˜“ç”¨æ€§ï¼ŒåŒæ—¶ï¼Œmodule ä¹Ÿä¸º crate æä¾›äº†è®¿é—®æƒé™æ§åˆ¶ï¼šå…è®¸æŸäº›å˜é‡å’Œæ–¹æ³•å…¬ç”¨æˆ–è€…ç§æœ‰ã€‚

ä½¿ç”¨ cargo åˆ›å»ºä¸€ä¸ª libraryï¼š

``` shell
$ cargo new --lib restaurant
$ cd restaurant
$ tree .
.
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â””â”€â”€ lib.rs

1 directory, 2 files
```

å¯ä»¥å°† lib.rs ä¸­çš„ä»£ç æ›´æ”¹ä¸ºï¼š

``` rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

ä½¿ç”¨ mod å…³é”®å­—å®šä¹‰ moduleï¼Œè€Œä¸”åœ¨ä¸€ä¸ª module ä¸­å¯ä»¥å®šä¹‰å…¶ä»– moduleï¼Œæ­¤å¤–ï¼Œmodule ä¸­è¿˜å¯ä»¥å®šä¹‰ structï¼Œenumï¼Œconstantsï¼Œtraitsï¼Œå‡½æ•°ç­‰ã€‚

src/msin.rs å’Œ src/lib.rs æ˜¯ crate rootï¼Œå…¶å†…çš„ module ç»„æˆäº† module tree çš„æ ¹éƒ¨ï¼Œå¦‚ä¸Šæ‰€ç¤ºçš„ modulesï¼Œå…¶ç»„æˆå¦‚ä¸‹ï¼š

``` shell
crate
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â””â”€â”€ take_payment
```

ä¸ºäº†ä½¿ç”¨åœ¨ module tree ä¸­çš„æŸä¸ª moduleï¼Œè¯¥å¦‚ä½•è¿›è¡Œå¼•ç”¨ï¼Ÿ

## å¼•ç”¨æ¨¡å—æ ‘ä¸­æŸä¸ªå¯¹è±¡çš„è·¯å¾„

ç±»ä¼¼äºæ–‡ä»¶ç³»ç»Ÿï¼Œrust æä¾›çš„ module ç³»ç»Ÿä¹Ÿæä¾›äº†ä¸¤ç§å¼•ç”¨æ–¹å¼ï¼š

- ä» crate root å¼€å§‹çš„ç»å¯¹å¼•ç”¨ï¼šä½¿ç”¨crate çš„åå­—æˆ–è€… crate å…³é”®å­—ï¼›
- ä»å½“å‰ module çš„ç›¸å¯¹å¼•ç”¨ï¼Œä½¿ç”¨ selfã€super æˆ–è€…å½“å‰æ¨¡å—çš„ idã€‚

æ¨¡å—çš„è·¯å¾„ä½¿ç”¨ "::" è¿›è¡Œè¿æ¥ï¼Œä¸‹é¢ï¼Œç®€å•åœ°ä½¿ç”¨è¿™ä¸¤ç§æ–¹æ³•æ¥è¿›è¡Œæ¨¡å—æ–¹æ³•çš„è°ƒç”¨ï¼š

``` rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}
pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();
    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

æ­¤å¤„ï¼Œeat_at_restaurant ä½œä¸º module çš„å…¬å…± api æš´éœ²ç»™ä½¿ç”¨è€…ï¼Œæ•…ä½¿ç”¨ pub æ ‡è®°ï¼Œåé¢å°†è¯¦ç»†ä»‹ç»ã€‚æ³¨æ„ä¸¤ç§è·¯å¾„å¼•ç”¨çš„æ–¹æ³•ï¼šå½“ä½¿ç”¨ç»å¯¹è·¯å¾„å¼•ç”¨æ—¶ï¼Œç”±äº eat_at_restaurant æ–¹æ³•å’Œ front_of_house åœ¨ç›¸åŒçš„ crate ä¸­ï¼Œå› æ­¤ï¼Œç»å¯¹è·¯å¾„çš„æ ¹å¯ä»¥ä½¿ç”¨ crate å…³é”®å­—ï¼Œåœ¨ crate å…³é”®å­—åï¼ŒæŒ‰åºç´¢å¼•åˆ°ç›®æ ‡å‡½æ•°ï¼›ç›¸å¯¹è·¯å¾„å¼•ç”¨åˆ™ä»¥ module åä½œä¸ºå¼€å§‹ï¼Œç›´è‡³ç´¢å¼•åˆ°ç›®æ ‡å‡½æ•°ã€‚

äºŒè€…çš„é€‰æ‹©ä¾æ®éœ€æ±‚ï¼Œä½†æ˜¯ç»å¯¹è·¯å¾„å¼•ç”¨åœ¨ç§»åŠ¨ä»£ç åï¼Œä¸éœ€è¦æ›´æ”¹å¼•ç”¨è·¯å¾„ã€‚

åœ¨è¯•å›¾ç¼–è¯‘ä¸Šè¿°ä»£ç æ—¶ï¼Œå°†æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå°½ç®¡å¼•ç”¨è·¯å¾„æ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯ï¼Œè¿˜å­˜åœ¨æ‰€æœ‰æƒé—®é¢˜ã€‚ä½¿ç”¨ module å¯ä»¥å®ç°å¯¹ä»£ç ç»†èŠ‚çš„å°è£…ï¼Œå¹¶å†³å®šæŸäº› api å¯ä»¥æš´éœ²ç»™å¤–é¢ã€‚rust é»˜è®¤æ‰€æœ‰çš„ moduleã€functionã€structã€enum ç­‰ï¼Œéƒ½æ˜¯ç§æœ‰çš„ï¼Œå³ä¸åŠ æŒ‡æ˜ï¼Œä¸èƒ½ä½¿ç”¨ï¼Œæ­¤æ—¶ï¼Œçˆ¶æ¨¡å—ä¸èƒ½ç›´æ¥ä½¿ç”¨å­æ¨¡å—çš„å†…å®¹ï¼Œä½†æ˜¯å­æ¨¡å—å¯ä»¥ä½¿ç”¨çˆ¶æ¨¡å—çš„å†…å®¹ï¼Œå› ä¸ºå­æ¨¡å—çš„å°è£…å‘å…¶å¤–éƒ¨éšè—äº†å®ç°çš„ç»†èŠ‚ï¼Œè€ŒåŒæ—¶å¯ä»¥çœ‹åˆ°å£°æ˜è¯¥å­æ¨¡å—çš„ä¸Šä¸‹æ–‡ã€‚

ä¸ºäº†ç»™å¤–éƒ¨æä¾›å¯ç”¨çš„æ¥å£ï¼Œéœ€è¦ä½¿ç”¨ pub å…³é”®å­—æŒ‡æ˜å…¶å…±æœ‰å±æ€§ï¼š

``` rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
```

éœ€è¦åŒæ—¶æŒ‡æ˜ hosting å’Œ add_to_waitlist ä¸º pubã€‚ä»éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äº front_of_house å’Œ eat_at_restaurant å®šä¹‰åœ¨åŒä¸€ä¸ª crate ä¸‹ï¼Œå› æ­¤ï¼Œå³ä½¿ front_of_house æ²¡æœ‰ pub æ ‡è®°ï¼Œå…¶ä»ç„¶å¯¹ eat_at_restaurant å¯è§ï¼Œä½†æ˜¯å¯¹äºæ­¤ module åŒ…å«çš„å†…å®¹ï¼Œéœ€è¦æ˜ç¡®æƒé™å†³å®šæ˜¯å¦æš´éœ²ç»™å¤–éƒ¨ä½¿ç”¨ã€‚

å¯¹äºç›¸å¯¹è·¯å¾„å¼•ç”¨ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ super å…³é”®å­—ï¼Œç±»ä¼¼äºæ–‡ä»¶ç³»ç»Ÿä¸­çš„ ".."ï¼Œå…¶æŒ‡å‘æ‰€åœ¨è·¯å¾„çš„ä¸Šä¸€çº§ã€‚ä¾‹å¦‚ï¼š

``` rust
fn server_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::server_order();
    }

    fn cook_order() {}
}
```

å‡½æ•° fix_incorrect_order æ˜¯ module back_of_house çš„å‡½æ•°ï¼Œå› æ­¤ï¼Œåœ¨è¯¥å‡½æ•°å†…éƒ¨å¯ä»¥ç›´æ¥å¼•ç”¨è¯¥ module çš„å‡½æ•° cook_orderï¼ŒåŒæ—¶ï¼Œé€šè¿‡ super å…³é”®å­—å°†è·¯å¾„æŒ‡å‘æ‰€åœ¨ module çš„çˆ¶è·¯å¾„ï¼Œä»è€Œè·å¾—å‡½æ•° server_orderã€‚ä»è¿™ä¸€ç‚¹æ¥è®²ï¼Œè‹¥èƒ½å¤Ÿä»å§‹è‡³ç»ˆä¿è¯ super æ‰€å¼•ç”¨çš„å¯¹è±¡å’Œå‘ç”Ÿçš„å¼•ç”¨ä½ç½®ç›¸å¯¹ä¸å˜ï¼Œå¯ä»¥ä½¿ç”¨ superã€‚

é™¤æ­¤ä»¥å¤–ï¼Œåœ¨ module ä¸­è®¾è®¡ structã€enum ç­‰å¯¹è±¡æ—¶ï¼Œä¹Ÿéœ€è¦æœ‰æ‰€æœ‰æƒçš„è€ƒè™‘ã€‚å¯¹äº structï¼Œé™¤äº†åœ¨ç±»å‹å…³é”®å­—å‰ä½¿ç”¨ pub è¡¨ç¤ºè¯¥å¯¹è±¡æ˜¯å¯è®¿é—®ä¹‹å¤–ï¼Œå…¶å†…éƒ¨å…ƒç´ é»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œé™¤éä½¿ç”¨ pub æ¥æ ‡è¯†å¯è®¿é—®ï¼š

``` rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
```

å¯¹äº enumï¼Œåªè¦åœ¨ å…³é”®å­—å‰æ ‡è®° pubï¼Œåˆ™å…¶å†…å®¹å‡å¯è®¿é—®ï¼Œä¸è¿‡ enum é»˜è®¤æƒ…å†µä¸‹ä¹Ÿæ˜¯å¯è®¿é—®çš„ï¼Œè€Œéç§æœ‰ã€‚

``` rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```

## é€šè¿‡ use å°†è·¯å¾„å¼•å…¥ä½œç”¨åŸŸ

ä»¥ä¸Šï¼Œæˆ‘ä»¬å­¦ä¹ é€šè¿‡ç»å¯¹è·¯å¾„æˆ–è€…ç›¸å¯¹è·¯å¾„ä»¥ä½¿ç”¨å¯¹åº”ç›®æ ‡ï¼Œä½†æ˜¯è¿‡äºç¹çï¼Œå¯ä»¥é€šè¿‡ use å…³é”®å­—å°†ç›´æ¥å°†ç›®æ ‡è·¯å¾„å¼•å…¥å½“å‰ä½œç”¨åŸŸä¸­ï¼š

``` rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;
// use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```

é€šè¿‡ useï¼Œå°† mod hosting å¼•å…¥åˆ° crate rootï¼Œå› æ­¤ï¼Œhosting å°†æˆä¸ºå½“å‰ä½œç”¨åŸŸçš„ä¸€ä¸ªåˆæ³•çš„åå­—ã€‚å¯ä»¥ç›´æ¥ä½¿ç”¨ hosting::xxxx æ¥å¼•ç”¨å¯¹åº”çš„ç›®æ ‡äº†ã€‚ä¹ æƒ¯ä¸Šï¼Œå¯¹äº mod ä¸­çš„å‡½æ•°ï¼Œå¼•å…¥å±‚çº§å°†åˆ°è¾¾å…¶ mod å±‚ï¼Œä»¥æ˜ç¡®è¯¥å‡½æ•°å®šä¹‰å†å…¶ä»–æ¨¡å—ä¸­ã€‚use å¯ä»¥ä½¿ç”¨ç›¸å¯¹è·¯å¾„æˆ–ç»å¯¹è·¯å¾„ã€‚

é™¤æ­¤ä»¥å¤–ï¼Œuse ä¹Ÿä¸ºæ¨¡å—å¼•å…¥æä¾›äº†åˆ«ååŠŸèƒ½ï¼š

``` rust
use std::io::Result as IoResult
```

ä½¿ç”¨ pub use å¯ä»¥å®ç°åå­—çš„ Re-exportingï¼ˆå¾…ç ”ç©¶ï¼Œä¸æ‡‚å•¥æ„æ€ï¼Œå¤§æ¦‚æ˜¯è™½ç„¶æ­¤å¤„æœªå®ç°è¯¥æ¥å£ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡ pub use å°†è¯¥æ¥å£æš´éœ²åˆ°æ­¤ä½ç½®ï¼Œä½œä¸ºæ­¤å¤„çš„æ¥å£ã€‚ã€‚ã€‚ï¼‰

ä»¥ä¸Šï¼Œæ˜¯å¼•å…¥è‡ªå·±å®ç°çš„æ¨¡å—ï¼Œè‹¥éœ€è¦ä½¿ç”¨å¤–éƒ¨æ¨¡å—ï¼Œåˆ™éœ€è¦ä¿®æ”¹ Cargo.toml æ–‡ä»¶ï¼ŒåŠ å…¥å¾…å¼•å…¥çš„æ¨¡å—å’Œç‰ˆæœ¬å·ï¼š

``` toml
[dependencies]
rand = "0.8.3"
```

æ­¤æ—¶ï¼ŒCargo å°†ä» crates.io ä¸‹è½½æ‰€æœ‰çš„ä¾èµ–ï¼Œå¹¶åœ¨è¯¥é¡¹ç›®ä¸­å¯ä»¥ä½¿ç”¨ rand æ¨¡å—ã€‚

``` rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¼•å…¥æ ‡å‡†åº“ std ä¸éœ€è¦ä¿®æ”¹ toml æ–‡ä»¶ï¼Œä½†éœ€è¦æ˜¾å¼ use æ¥å¯¼å…¥éœ€è¦ä½¿ç”¨çš„å¯¹è±¡ååˆ°å½“å‰ä½œç”¨åŸŸä¸­ã€‚

è‹¥éœ€è¦å¼•å…¥ç›¸åŒæ¨¡å—ä¸‹ä¸åŒçš„å­æ¨¡å—ï¼Œä»¥ä¸‹æ˜¯æ›´ç®€ä¾¿çš„æ–¹æ³•ï¼š

``` rust
use std::{cmp::Ordering, io};
```

åˆå¦‚ï¼š

``` rust
use std::io;
use std::io::Write;

// ->
use std::io::{self, Write};
```

è‹¥éœ€è¦å¼•å…¥æŸä¸ªæ¨¡å—ä¸‹çš„æ‰€æœ‰å†…å®¹ï¼Œä½¿ç”¨ * ï¼š

``` rust
use std::collections::*;
```

## å°†æ¨¡å—æ‹†åˆ†åˆ°ä¸åŒæ–‡ä»¶

éšç€ä»£ç é‡çš„å¢å¤§ï¼Œåœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­ä¹¦å†™å¹¶ä¸æ˜¯ä¸€ä¸ªå¥½çš„ä»£ç ç»„ç»‡æ–¹å¼ã€‚




 Waiting for update later
